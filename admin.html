<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spot On! Admin v2.2.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Urbanist:wght@400;500;600;700;800&family=Questrial&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-dark: #1a1a1a;
            --bg-panel: #2a2a2a;
            --accent-primary: #7BAFD4; /* Carolina Blue */
            --accent-light: #a8d1f0;   /* Lighter Carolina Blue */
            --accent-success: #6fbf73; /* Muted green for success */
            --accent-warning: #f5a623; /* Warning/yellow */
            --accent-danger: #e74c3c;  /* Danger red */
            --text-primary: #ffffff;
            --text-muted: #9ca3af;
            --border-color: #444444;
            --grey-medium: #666666;
        }
        
        * { box-sizing: border-box; }
        
        body {
            font-family: 'Century Gothic', 'Urbanist', 'Questrial', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
        }
        
        h1, h2, h3, .heading { font-family: 'Century Gothic', 'Urbanist', 'Questrial', sans-serif; font-weight: 700; }
        .glow-primary { text-shadow: 0 0 20px var(--accent-primary); }
        
        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 12px;
        }
        
        .btn {
            font-family: 'Century Gothic', 'Urbanist', 'Questrial', sans-serif;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 700;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 1px;
            transition: all 0.2s ease;
            cursor: pointer;
            border: 2px solid transparent;
        }
        
        .btn-cyan { background: var(--accent-primary); color: var(--bg-dark); }
        .btn-cyan:hover { box-shadow: 0 0 20px var(--accent-primary); transform: translateY(-1px); }
        .btn-magenta { background: var(--grey-medium); color: white; }
        .btn-magenta:hover { box-shadow: 0 0 10px var(--grey-medium); }
        .btn-green { background: var(--accent-success); color: var(--bg-dark); }
        .btn-green:hover { box-shadow: 0 0 20px var(--accent-success); }
        .btn-blue { background: var(--accent-primary); color: var(--bg-dark); }
        .btn-blue:hover { box-shadow: 0 0 20px var(--accent-primary); }
        .btn-outline { background: transparent; border: 2px solid var(--border-color); color: var(--text-primary); }
        .btn-outline:hover { border-color: var(--accent-primary); color: var(--accent-primary); }
        .btn-danger { background: var(--accent-danger); color: white; }
        .btn-sm { padding: 6px 12px; font-size: 10px; }
        
        .btn-active { box-shadow: 0 0 15px currentColor; }
        
        input, textarea, select {
            background: rgba(255,255,255,0.08);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            color: var(--text-primary);
            font-family: 'Century Gothic', 'Urbanist', 'Questrial', sans-serif;
            font-size: 13px;
            width: 100%;
        }
        input:focus, textarea:focus, select:focus { outline: none; border-color: var(--accent-primary); }
        
        #cropContainer {
            position: relative;
            background: #1a1a2e;
            border-radius: 8px;
            overflow: hidden;
        }
        
        #cropCanvas {
            display: block;
            max-width: 100%;
            max-height: 500px;
            margin: 0 auto;
        }
        
        #zoneContainer {
            position: relative;
            background: #1a1a2e;
            border-radius: 8px;
            overflow: hidden;
            background-size: 100% 100%;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        #canvasWrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            border-radius: 8px;
        }
        
        #interactionLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            border-radius: 8px;
        }
        
        .zone-set-item {
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .zone-set-item:hover { border-color: var(--accent-primary); }
        .zone-set-item.selected { 
            border-color: var(--accent-primary); 
            background: rgba(0, 245, 212, 0.1);
        }
        .zone-set-item.white-set { border-left: 4px solid #fff; }
        .zone-set-item.black-set { border-left: 4px solid #666; }
        
        .mode-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
        }
        .mode-draw { background: rgba(74, 222, 128, 0.2); color: var(--accent-green); }
        .mode-edit { background: rgba(59, 130, 246, 0.2); color: var(--accent-blue); }
        
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 16px 24px;
            border-radius: 8px;
            font-weight: 600;
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }
        .toast-success { background: #059669; }
        .toast-error { background: #dc2626; }
        .toast-info { background: #3b82f6; }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* Primary tabs (Sweet Spot, Picture Perfect, Leaderboards) */
        .tab-btn {
            padding: 12px 24px;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
        }
        .tab-btn.active { border-bottom-color: var(--accent-primary); color: var(--accent-primary); }
        
        /* Secondary/sub tabs */
        .sub-tabs {
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--border-color);
        }
        .sub-tab-btn {
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            color: var(--text-muted);
            border-bottom: 2px solid transparent;
        }
        .sub-tab-btn:hover { color: var(--text-primary); }
        .sub-tab-btn.active { 
            color: var(--accent-primary); 
            border-bottom-color: var(--accent-primary);
        }
        
        .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
        .status-connected { background: #4ade80; }
        .status-disconnected { background: #dc2626; }
        
        .hidden { display: none !important; }
        
        .help-text { font-size: 11px; color: var(--text-muted); margin-top: 4px; }
        
        .distance-label {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: var(--accent-primary);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            pointer-events: none;
        }
        
        .level-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.2s;
            cursor: pointer;
        }
        .level-card:hover { border-color: var(--accent-primary); transform: translateY(-4px); }
        .level-card img { width: 100%; height: 150px; object-fit: cover; }
    </style>
</head>
<body>
    <!-- Login Overlay -->
    <div id="loginOverlay" class="fixed inset-0 bg-black flex items-center justify-center z-[200]">
        <div class="text-center">
            <h1 class="text-4xl font-bold heading glow-primary mb-2">SPOT ON!</h1>
            <p class="text-gray-400 mb-8">Admin Panel</p>
            <button id="googleSignInBtn" class="btn btn-cyan flex items-center gap-3 mx-auto">
                <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="currentColor" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="currentColor" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="currentColor" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                Sign in with Google
            </button>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="text-center">
            <div class="spinner mx-auto mb-4"></div>
            <p id="loadingText">Loading...</p>
        </div>
    </div>

    <!-- Header -->
    <header class="border-b border-gray-800 py-3 px-6">
        <div class="max-w-7xl mx-auto flex items-center justify-between">
            <div class="flex items-center gap-4">
                <h1 class="text-xl font-bold heading glow-primary">SPOT ON!</h1>
                <span class="text-xs bg-gray-800 px-3 py-1 rounded-full">ADMIN</span>
            </div>
            <div class="flex items-center gap-4">
                <div class="flex items-center gap-2 text-sm">
                    <span class="status-dot" id="connectionStatus"></span>
                    <span id="connectionText" class="text-xs">Checking...</span>
                </div>
                <div id="userInfo" class="hidden items-center gap-3">
                    <span id="userName" class="text-sm text-gray-400"></span>
                    <button id="signOutBtn" class="text-xs text-gray-500 hover:text-red-400">Sign Out</button>
                </div>
                <a href="index.html" class="btn btn-outline btn-sm">‚Üê Back to Games</a>
            </div>
        </div>
    </header>

    <!-- Primary Tabs -->
    <div class="border-b border-gray-800">
        <div class="max-w-7xl mx-auto flex">
            <button class="tab-btn active" data-tab="sweetspot">Sweet Spot</button>
            <button class="tab-btn" data-tab="pictureperfect">Picture Perfect</button>
            <button class="tab-btn" data-tab="leaderboards">Leaderboards</button>
            <button class="tab-btn hidden" data-tab="migrate" id="migrateTabBtn">Migration</button>
        </div>
    </div>
    
    <!-- Sweet Spot Sub-tabs (shown when Sweet Spot tab is active) -->
    <div id="sweetspotSubTabs" class="sub-tabs">
        <div class="max-w-7xl mx-auto flex">
            <button class="sub-tab-btn active" data-subtab="editor">Level Editor</button>
            <button class="sub-tab-btn" data-subtab="levels">All Levels</button>
        </div>
    </div>

    <!-- Main Content -->
    <main class="max-w-7xl mx-auto p-4">
        
        <!-- Sweet Spot Tab Container -->
        <div id="sweetspotTab" class="tab-content">
            <!-- Editor Sub-tab -->
            <div id="editorSubTab" class="sub-tab-content">
            <div class="grid grid-cols-1 lg:grid-cols-12 gap-4">
                
                <!-- Left Panel: Canvas (8 cols) -->
                <div class="lg:col-span-8">
                    <div class="panel p-4">
                        <!-- Image Controls -->
                        <div class="flex items-center justify-between mb-3">
                            <h2 class="text-lg font-bold heading">Image Canvas</h2>
                            <div class="flex gap-2">
                                <label class="btn btn-outline btn-sm cursor-pointer">
                                    Upload
                                    <input type="file" id="imageUpload" accept="image/*,video/webm" class="hidden">
                                </label>
                            </div>
                        </div>
                        
                        <div class="flex gap-2 mb-3">
                            <input type="text" id="imageUrlInput" placeholder="Or paste image URL..." class="flex-1 text-sm">
                            <button id="loadUrlBtn" class="btn btn-cyan btn-sm">Load</button>
                        </div>
                        
                        <!-- View Toggle -->
                        <div class="flex gap-2 mb-3 p-2 bg-black/30 rounded-lg">
                            <button id="cropViewBtn" class="btn btn-sm btn-cyan btn-active flex-1">1. Set Crop Area</button>
                            <button id="zoneViewBtn" class="btn btn-sm btn-outline flex-1">2. Draw Zones</button>
                        </div>
                        
                        <!-- Canvas Area for Crop View (shows full image with crop overlay) -->
                        <div id="cropContainer" class="relative bg-black/30 rounded-lg overflow-hidden" style="min-height: 300px;">
                            <canvas id="cropCanvas"></canvas>
                            <p id="cropPlaceholder" class="text-gray-500 absolute inset-0 flex items-center justify-center">Upload an image to set crop area</p>
                        </div>
                        
                        <!-- Canvas Area for Zone View (shows cropped region only) -->
                        <div id="zoneContainer" class="hidden relative bg-black/30 rounded-lg overflow-hidden" style="aspect-ratio: 4/3; max-width: 600px; margin: 0 auto;">
                            <div id="canvasWrapper" style="position: absolute; inset: 0;">
                                <canvas id="overlayCanvas"></canvas>
                                <canvas id="interactionLayer"></canvas>
                            </div>
                            <p id="zonePlaceholder" class="text-gray-500 absolute inset-0 flex items-center justify-center hidden">Set crop area first</p>
                        </div>
                        
                        <!-- Crop Mode Tools -->
                        <div id="cropTools" class="mt-3 flex flex-wrap gap-3 items-center">
                            <div class="flex items-center gap-2">
                                <span class="text-sm text-gray-400">Drag the crop box corners to resize, or drag inside to move</span>
                            </div>
                            <button id="resetCropBtn" class="btn btn-outline btn-sm ml-auto">Reset to Auto</button>
                        </div>
                        
                        <!-- Zone Mode Tools (hidden when in crop view) -->
                        <div id="zoneTools" class="mt-3 flex flex-wrap gap-3 items-center hidden">
                            <div class="flex items-center gap-2">
                                <span class="mode-indicator" id="modeIndicator">
                                    <span class="mode-dot"></span>
                                    <span id="modeText">Select Mode</span>
                                </span>
                            </div>
                            
                            <div class="flex gap-2 ml-auto">
                                <button id="toggleZonesBtn" class="btn btn-outline btn-sm" title="Toggle zone visibility">üëÅ Zones</button>
                                <button id="selectModeBtn" class="btn btn-blue btn-sm btn-active">Select</button>
                                <button id="drawGoodBtn" class="btn btn-green btn-sm">+ Good Zone</button>
                                <button id="drawPerfectBtn" class="btn btn-blue btn-sm">+ Perfect Zone</button>
                                <button id="autoPerfectBtn" class="btn btn-outline btn-sm" title="Auto-place perfect zone in center of selected good zone">‚ö° Auto Perfect</button>
                            </div>
                        </div>
                        
                        <!-- Instructions -->
                        <div class="mt-3 p-3 bg-black/30 rounded-lg">
                            <p class="text-xs text-gray-400" id="instructions">
                                <strong>Good Zones:</strong> Click to add polygon points, click near start to close shape.<br>
                                <strong>Perfect Zone:</strong> Draw rectangle OR select a good zone and click "Auto Perfect" to place it automatically.<br>
                                <strong>Editing:</strong> Drag vertices to reshape, drag inside to move. Delete key removes selected zone/vertex.
                            </p>
                        </div>
                    </div>
                </div>
                
                <!-- Right Panel: Zone Sets (4 cols) -->
                <div class="lg:col-span-4 space-y-4">
                    
                    <!-- Level Info -->
                    <div class="panel p-4">
                        <h3 class="font-bold heading mb-3 text-sm">Level Info</h3>
                        <div class="space-y-3">
                            <div>
                                <label class="text-xs text-gray-400">Level Name</label>
                                <input type="text" id="levelName" placeholder="e.g., Mountain Lake" class="text-sm">
                            </div>
                            <div>
                                <label class="text-xs text-gray-400">"No Good Spot" Feedback</label>
                                <textarea id="levelFeedback" rows="2" placeholder="Shown when image has no good spots..." class="text-sm"></textarea>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Zone Sets -->
                    <div class="panel p-4">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="font-bold heading text-sm">Zone Sets</h3>
                            <button id="addZoneSetBtn" class="btn btn-cyan btn-sm">+ New Set</button>
                        </div>
                        
                        <div id="zoneSetsList" class="space-y-2 max-h-[250px] overflow-y-auto">
                            <p class="text-gray-500 text-sm text-center py-4">No zone sets yet</p>
                        </div>
                    </div>
                    
                    <!-- Selected Zone Set Editor -->
                    <div id="zoneSetEditor" class="panel p-4 hidden">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="font-bold heading text-sm">Edit Zone Set</h3>
                            <button id="deleteZoneSetBtn" class="btn btn-danger btn-sm">Delete Set</button>
                        </div>
                        
                        <div class="space-y-3">
                            <div>
                                <label class="text-xs text-gray-400">Set Name</label>
                                <input type="text" id="zoneSetName" placeholder="e.g., Above Water" class="text-sm">
                            </div>
                            <div>
                                <label class="text-xs text-gray-400">Text Color</label>
                                <div class="flex gap-2 mt-1">
                                    <button class="btn btn-sm flex-1 color-btn" data-color="white" style="background:#fff;color:#000;">White</button>
                                    <button class="btn btn-sm flex-1 color-btn" data-color="black" style="background:#333;color:#fff;">Black</button>
                                </div>
                            </div>
                            <div>
                                <label class="text-xs text-gray-400">Placement Feedback</label>
                                <textarea id="zoneSetFeedback" rows="2" placeholder="Shown after player places text..." class="text-sm"></textarea>
                            </div>
                            <div>
                                <label class="text-xs text-gray-400">Perfect Zone Hint</label>
                                <textarea id="perfectZoneHint" rows="2" placeholder="Hint for near-perfect placements..." class="text-sm"></textarea>
                            </div>
                            
                            <div class="pt-2 border-t border-gray-700">
                                <p class="text-xs text-gray-400 mb-2">Zones in this set:</p>
                                <div id="setZonesList" class="text-xs space-y-1">
                                    <p class="text-gray-500">No zones yet</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Actions -->
                    <div class="panel p-4 space-y-2">
                        <button id="saveLevelBtn" class="btn btn-cyan w-full">Save Level</button>
                        <button id="newLevelBtn" class="btn btn-outline w-full">New Level</button>
                    </div>
                </div>
            </div>
            </div>
            <!-- End Editor Sub-tab -->
        
            <!-- Levels Sub-tab -->
            <div id="levelsSubTab" class="sub-tab-content hidden">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-xl font-bold heading">All Levels</h2>
                <button id="refreshLevelsBtn" class="btn btn-outline btn-sm">Refresh</button>
            </div>
            <div id="levelsList" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
                <p class="text-gray-500 col-span-full text-center py-12">Loading...</p>
            </div>
            </div>
            <!-- End Levels Sub-tab -->
        </div>
        <!-- End Sweet Spot Tab -->
        
        <!-- Migration Tab -->
        <div id="migrateTab" class="tab-content hidden">
            <div class="max-w-2xl mx-auto panel p-6">
                <h2 class="text-xl font-bold heading mb-2">Migrate Original Images</h2>
                <p class="text-gray-400 mb-6">Download original game images and upload them to Firebase.</p>
                
                <div id="migrationProgress" class="hidden mb-6">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm">Progress</span>
                        <span id="migrationCount" class="text-sm">0 / 10</span>
                    </div>
                    <div class="h-2 bg-gray-800 rounded-full overflow-hidden">
                        <div id="migrationBar" class="h-full bg-gradient-to-r from-cyan-400 to-blue-500 transition-all" style="width: 0%"></div>
                    </div>
                    <div id="migrationLog" class="mt-4 bg-black/50 rounded-lg p-4 max-h-[300px] overflow-y-auto font-mono text-xs space-y-1"></div>
                </div>
                
                <button id="startMigrationBtn" class="btn btn-magenta">Start Migration</button>
            </div>
        </div>
        
        <!-- Leaderboards Tab -->
        <div id="leaderboardsTab" class="tab-content hidden">
            <div class="panel p-6">
                <div class="flex items-center justify-between mb-6">
                    <h2 class="text-xl font-bold heading">üèÜ Leaderboard</h2>
                    <div class="flex gap-2">
                        <button id="refreshScoresBtn" class="btn btn-outline btn-sm">‚Üª Refresh</button>
                        <button id="exportScoresBtn" class="btn btn-cyan btn-sm">Export CSV</button>
                    </div>
                </div>
                
                <!-- Filters -->
                <div class="flex flex-wrap gap-4 mb-4">
                    <div class="flex items-center gap-2">
                        <label class="text-sm text-gray-400">Game:</label>
                        <select id="scoresGameFilter" class="text-sm bg-gray-800 border border-gray-700 rounded px-2 py-1">
                            <option value="all">All Games</option>
                            <option value="sweet-spot">Sweet Spot</option>
                            <option value="find-the-center">Find the Center</option>
                            <option value="perfect-alignment">Perfect Alignment</option>
                            <option value="balanced-placement">Balanced Placement</option>
                            <option value="picture-perfect">Picture Perfect</option>
                        </select>
                    </div>
                    <div class="flex items-center gap-2">
                        <label class="text-sm text-gray-400">Player:</label>
                        <input type="text" id="scoresPlayerSearch" placeholder="Search email or name..." class="text-sm bg-gray-800 border border-gray-700 rounded px-2 py-1 w-48">
                    </div>
                    <div class="flex items-center gap-2">
                        <label class="text-sm text-gray-400">Status:</label>
                        <select id="scoresFilter" class="text-sm bg-gray-800 border border-gray-700 rounded px-2 py-1">
                            <option value="all">All Scores</option>
                            <option value="flagged">Flagged Only</option>
                            <option value="unflagged">Unflagged Only</option>
                        </select>
                    </div>
                    <div class="flex items-center gap-2">
                        <label class="text-sm text-gray-400">Limit:</label>
                        <select id="scoresLimit" class="text-sm bg-gray-800 border border-gray-700 rounded px-2 py-1">
                            <option value="50">50</option>
                            <option value="100">100</option>
                            <option value="500">500</option>
                            <option value="1000">1000</option>
                        </select>
                    </div>
                </div>
                
                <!-- Scores Table -->
                <div class="overflow-x-auto">
                    <table class="w-full text-sm">
                        <thead>
                            <tr class="border-b border-gray-700 text-left">
                                <th class="py-3 px-2 w-16">Rank</th>
                                <th class="py-3 px-2 w-28">Game</th>
                                <th class="py-3 px-2 w-20">Initials</th>
                                <th class="py-3 px-2 w-20">Score</th>
                                <th class="py-3 px-2">Email</th>
                                <th class="py-3 px-2">Name</th>
                                <th class="py-3 px-2 w-36">Date</th>
                                <th class="py-3 px-2 w-24">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="scoresTableBody">
                            <tr><td colspan="8" class="py-8 text-center text-gray-500">Loading scores...</td></tr>
                        </tbody>
                    </table>
                </div>
                
                <p id="scoresTotalCount" class="text-sm text-gray-500 mt-4"></p>
            </div>
        </div>
        
        <!-- Picture Perfect Images Tab -->
        <!-- Picture Perfect Tab -->
        <div id="pictureperfectTab" class="tab-content hidden">
            <div class="panel p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold glow-primary">Picture Perfect Images</h2>
                    <div class="flex gap-2">
                        <button id="ppMigrateBtn" class="btn btn-outline btn-sm">Seed Default Images</button>
                        <button id="ppRefreshBtn" class="btn btn-outline btn-sm">Refresh</button>
                    </div>
                </div>
                
                <!-- Add Image Form -->
                <div class="mb-6 p-4 bg-gray-800 rounded-lg">
                    <h3 class="font-semibold mb-3">Add New Image</h3>
                    <div class="flex gap-3">
                        <input type="text" id="ppNewImageUrl" placeholder="Image URL (Pexels, Unsplash, or any direct image link)" class="flex-1">
                        <input type="text" id="ppNewImageName" placeholder="Name (optional)" class="w-48">
                        <button id="ppAddImageBtn" class="btn btn-cyan">Add Image</button>
                    </div>
                    <p class="text-xs text-gray-500 mt-2">Tip: Use Pexels.com or Unsplash.com for free, high-quality images. Right-click an image and "Copy image address".</p>
                </div>
                
                <!-- Image Stats -->
                <div class="mb-4 flex gap-4 text-sm">
                    <span id="ppTotalCount" class="text-gray-400">Total: 0</span>
                    <span id="ppEnabledCount" class="text-green-400">Enabled: 0</span>
                    <span id="ppDisabledCount" class="text-gray-500">Disabled: 0</span>
                </div>
                
                <!-- Images Grid -->
                <div id="ppImagesList" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    <p class="text-gray-500 col-span-full text-center py-8">Loading images...</p>
                </div>
            </div>
        </div>
    </main>

    <script type="module">
        // ============================================
        // FIREBASE IMPORTS
        // ============================================
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithPopup, signOut as firebaseSignOut, onAuthStateChanged, GoogleAuthProvider } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, getDocs, getDoc, addDoc, updateDoc, deleteDoc, serverTimestamp, query, orderBy, where, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        // ============================================
        // FIREBASE CONFIG & INIT
        // ============================================
        const firebaseConfig = {
            apiKey: "AIzaSyDfo45UBu-pR8nqMQhVlS_QgyYZ2kzBdvM",
            authDomain: "ellisbell-c185c.firebaseapp.com",
            projectId: "ellisbell-c185c",
            storageBucket: "ellisbell-c185c.firebasestorage.app",
            appId: "1:441560045695:web:94e51a006663404b8f474a"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);
        
        let currentUser = null;
        let firebaseReady = false;

        // ============================================
        // STATE
        // ============================================
        
        // Set to true to enable verbose console logging
        const DEBUG = false;
        
        // Level data structure
        let currentLevel = {
            id: null,
            name: '',
            imageUrl: '',
            imagePath: '',
            // Crop rectangle as percentages of original image (null = auto-fit to 4:3)
            // { x: 0, y: 0, width: 100, height: 75 } would show top 75% of image
            crop: null,
            feedback: '', // "No good spot" feedback
            zoneSets: []  // Array of zone sets
        };
        
        /*
        Zone Set structure:
        {
            id: 'set_1',
            name: 'Above Water',
            color: 'white', // or 'black'
            placementFeedback: '',
            perfectHint: '',
            goodZones: [{ points: [{x, y}, {x, y}, ...] }],  // Polygon as array of percentage points
            perfectZone: { x, y, width, height } // Rectangle only
        }
        
        Legacy format (auto-converted on load):
        goodZones: [{ x, y, width, height }]  // Converted to 4-point polygon
        */
        
        // Editor state
        let editorMode = 'select'; // 'select', 'drawGood', 'drawPerfect'
        let editorView = 'crop'; // 'crop' or 'zones'
        let selectedSetId = null;
        let selectedZoneType = null; // 'good' or 'perfect'
        let selectedZoneIndex = null;
        let selectedVertexIndex = null; // For polygon vertex selection
        let dragHandle = null; // Which handle is being dragged
        let isDrawing = false;
        let drawStart = { x: 0, y: 0 };
        let tempZone = null;
        let polygonPoints = []; // Points being drawn for new polygon
        let zonesVisible = true; // Toggle for zone visibility
        let hiddenSets = new Set(); // Track which sets are hidden (UI only, not saved)
        
        // Undo/Redo history
        let undoHistory = [];
        let redoHistory = [];
        const MAX_UNDO_HISTORY = 50;
        
        // Track unsaved changes
        let isDirty = false;
        
        // Canvas refs
        let overlayCanvas, overlayCtx;
        let interactionCanvas;
        let loadedImage = null;
        
        // Text dimensions are calculated dynamically based on actual rendered text
        // These will be updated when canvas is ready
        let TEXT_WIDTH_PERCENT = 32;  // Default, will be recalculated
        let TEXT_HEIGHT_PERCENT = 20; // Default, will be recalculated
        
        // Minimum zone sizes (will update with text measurements)
        let PERFECT_MIN_WIDTH = TEXT_WIDTH_PERCENT;
        let PERFECT_MIN_HEIGHT = TEXT_HEIGHT_PERCENT;
        
        // Measure actual text size and update constants
        function measureTextDimensions() {
            if (!overlayCanvas || overlayCanvas.width === 0) return;
            
            const canvasHeight = overlayCanvas.height;
            const canvasWidth = overlayCanvas.width;
            const fontSize = canvasHeight * 0.09; // Same as in drawTextPreview
            
            overlayCtx.font = `bold ${fontSize}px 'Century Gothic', sans-serif`;
            const textWidth = overlayCtx.measureText('This Text').width;
            // Two lines: lineHeight (1.15) + one fontSize = ~2.15 total
            const textHeight = fontSize * 2.2;
            
            // Convert to percentages
            TEXT_WIDTH_PERCENT = (textWidth / canvasWidth) * 100;
            TEXT_HEIGHT_PERCENT = (textHeight / canvasHeight) * 100;
            
            // Update dependent constants
            PERFECT_MIN_WIDTH = TEXT_WIDTH_PERCENT;
            PERFECT_MIN_HEIGHT = TEXT_HEIGHT_PERCENT;
            
            if (DEBUG) console.log('Text measured:', TEXT_WIDTH_PERCENT.toFixed(1) + '% x ' + TEXT_HEIGHT_PERCENT.toFixed(1) + '%');
        }

        // ============================================
        // UI HELPERS
        // ============================================
        function showLoading(text = 'Loading...') {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingOverlay').classList.remove('hidden');
        }
        
        function hideLoading() {
            document.getElementById('loadingOverlay').classList.add('hidden');
        }
        
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }
        
        function showConnectionStatus(connected, text) {
            document.getElementById('connectionStatus').className = 'status-dot ' + (connected ? 'status-connected' : 'status-disconnected');
            document.getElementById('connectionText').textContent = text;
        }
        
        // ============================================
        // POLYGON HELPER FUNCTIONS
        // ============================================
        
        // Convert legacy rectangle to polygon format
        function rectToPolygon(rect) {
            return {
                points: [
                    { x: rect.x, y: rect.y },
                    { x: rect.x + rect.width, y: rect.y },
                    { x: rect.x + rect.width, y: rect.y + rect.height },
                    { x: rect.x, y: rect.y + rect.height }
                ]
            };
        }
        
        // Check if a good zone is in legacy rectangle format
        function isLegacyRect(zone) {
            return zone.hasOwnProperty('width') && zone.hasOwnProperty('height') && !zone.hasOwnProperty('points');
        }
        
        // Convert zone to polygon if needed
        function ensurePolygon(zone) {
            if (isLegacyRect(zone)) {
                return rectToPolygon(zone);
            }
            return zone;
        }
        
        // ============================================
        // UNDO/REDO SYSTEM
        // ============================================
        function saveUndoState(description = '') {
            // Deep clone current zone sets
            const state = {
                zoneSets: JSON.parse(JSON.stringify(currentLevel.zoneSets)),
                selectedSetId,
                selectedZoneType,
                selectedZoneIndex,
                description
            };
            undoHistory.push(state);
            if (undoHistory.length > MAX_UNDO_HISTORY) {
                undoHistory.shift();
            }
            // Clear redo history when new action is taken
            redoHistory = [];
            // Mark as dirty
            isDirty = true;
        }
        
        function undo() {
            if (undoHistory.length === 0) {
                showToast('Nothing to undo', 'info');
                return;
            }
            
            // Save current state to redo history first
            redoHistory.push({
                zoneSets: JSON.parse(JSON.stringify(currentLevel.zoneSets)),
                selectedSetId,
                selectedZoneType,
                selectedZoneIndex,
                description: 'redo'
            });
            
            const state = undoHistory.pop();
            currentLevel.zoneSets = state.zoneSets;
            selectedSetId = state.selectedSetId;
            selectedZoneType = state.selectedZoneType;
            selectedZoneIndex = state.selectedZoneIndex;
            
            updateZoneSetsList();
            updateZoneSetEditor();
            redrawOverlay();
            showToast('Undone' + (state.description ? ': ' + state.description : ''), 'info');
        }
        
        function redo() {
            if (redoHistory.length === 0) {
                showToast('Nothing to redo', 'info');
                return;
            }
            
            // Save current state to undo history first
            undoHistory.push({
                zoneSets: JSON.parse(JSON.stringify(currentLevel.zoneSets)),
                selectedSetId,
                selectedZoneType,
                selectedZoneIndex,
                description: 'undo'
            });
            
            const state = redoHistory.pop();
            currentLevel.zoneSets = state.zoneSets;
            selectedSetId = state.selectedSetId;
            selectedZoneType = state.selectedZoneType;
            selectedZoneIndex = state.selectedZoneIndex;
            
            updateZoneSetsList();
            updateZoneSetEditor();
            redrawOverlay();
            showToast('Redone', 'info');
        }
        
        // Point-in-polygon test using ray casting algorithm
        function pointInPolygon(px, py, polygon) {
            const points = polygon.points;
            let inside = false;
            
            for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                const xi = points[i].x, yi = points[i].y;
                const xj = points[j].x, yj = points[j].y;
                
                if (((yi > py) !== (yj > py)) &&
                    (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            
            return inside;
        }
        
        // Calculate polygon centroid (center of mass)
        function getPolygonCentroid(polygon) {
            const points = polygon.points;
            let cx = 0, cy = 0, area = 0;
            
            for (let i = 0; i < points.length; i++) {
                const j = (i + 1) % points.length;
                const cross = points[i].x * points[j].y - points[j].x * points[i].y;
                area += cross;
                cx += (points[i].x + points[j].x) * cross;
                cy += (points[i].y + points[j].y) * cross;
            }
            
            area /= 2;
            cx /= (6 * area);
            cy /= (6 * area);
            
            return { x: cx, y: cy };
        }
        
        // Get bounding box of polygon
        function getPolygonBounds(polygon) {
            const points = polygon.points;
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            
            points.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });
            
            return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        }
        
        // Convert polygon points from percentages to pixels
        function polygonToPixels(polygon) {
            return polygon.points.map(p => ({
                x: (p.x / 100) * overlayCanvas.width,
                y: (p.y / 100) * overlayCanvas.height
            }));
        }
        
        // Convert pixel coordinates to percentages
        function pixelToPercent(x, y) {
            return {
                x: Math.round((x / overlayCanvas.width) * 10000) / 100,
                y: Math.round((y / overlayCanvas.height) * 10000) / 100
            };
        }
        
        // Find distance from point to polygon edge (for finding innermost point)
        function distanceToPolygonEdge(px, py, polygon) {
            const points = polygon.points;
            let minDist = Infinity;
            
            for (let i = 0; i < points.length; i++) {
                const j = (i + 1) % points.length;
                const dist = distanceToLineSegment(px, py, points[i].x, points[i].y, points[j].x, points[j].y);
                minDist = Math.min(minDist, dist);
            }
            
            return minDist;
        }
        
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSq = dx * dx + dy * dy;
            
            if (lengthSq === 0) return Math.hypot(px - x1, py - y1);
            
            let t = ((px - x1) * dx + (py - y1) * dy) / lengthSq;
            t = Math.max(0, Math.min(1, t));
            
            const nearX = x1 + t * dx;
            const nearY = y1 + t * dy;
            
            return Math.hypot(px - nearX, py - nearY);
        }
        
        // Check if two line segments intersect
        // Uses cross product method to detect intersection
        function lineSegmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            // Direction vectors
            const d1x = x2 - x1, d1y = y2 - y1;
            const d2x = x4 - x3, d2y = y4 - y3;
            
            // Cross product of directions
            const cross = d1x * d2y - d1y * d2x;
            
            // If cross product is 0, lines are parallel
            if (Math.abs(cross) < 0.0001) return false;
            
            // Calculate parameters for intersection point
            const dx = x3 - x1, dy = y3 - y1;
            const t = (dx * d2y - dy * d2x) / cross;
            const u = (dx * d1y - dy * d1x) / cross;
            
            // Check if intersection point is within both segments
            return t >= 0 && t <= 1 && u >= 0 && u <= 1;
        }
        
        // Check if any polygon edge intersects any rectangle edge
        function polygonIntersectsRectangle(polygon, left, top, right, bottom) {
            // Rectangle edges
            const rectEdges = [
                [left, top, right, top],       // Top edge
                [right, top, right, bottom],   // Right edge
                [right, bottom, left, bottom], // Bottom edge
                [left, bottom, left, top]      // Left edge
            ];
            
            // Check each polygon edge against each rectangle edge
            const points = polygon.points;
            for (let i = 0; i < points.length; i++) {
                const j = (i + 1) % points.length;
                const px1 = points[i].x, py1 = points[i].y;
                const px2 = points[j].x, py2 = points[j].y;
                
                for (const [rx1, ry1, rx2, ry2] of rectEdges) {
                    if (lineSegmentsIntersect(px1, py1, px2, py2, rx1, ry1, rx2, ry2)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // Find the best position for perfect zone within a polygon
        function findBestPerfectZonePosition(polygon) {
            const halfW = PERFECT_MIN_WIDTH / 2;
            const halfH = PERFECT_MIN_HEIGHT / 2;
            
            // Check if a rectangle centered at (cx, cy) fits entirely inside the polygon
            // Must verify: 
            // 1) All corners inside polygon
            // 2) No polygon vertices inside rectangle
            // 3) No polygon edges intersect rectangle edges (handles concave shapes)
            function rectangleFitsAt(cx, cy) {
                const left = cx - halfW;
                const right = cx + halfW;
                const top = cy - halfH;
                const bottom = cy + halfH;
                
                // Check all 4 corners are inside polygon
                const corners = [
                    { x: left, y: top },
                    { x: right, y: top },
                    { x: left, y: bottom },
                    { x: right, y: bottom }
                ];
                if (!corners.every(c => pointInPolygon(c.x, c.y, polygon))) {
                    return false;
                }
                
                // Check no polygon vertices are inside the rectangle
                for (const pt of polygon.points) {
                    if (pt.x > left && pt.x < right && pt.y > top && pt.y < bottom) {
                        return false; // Polygon vertex inside rectangle = bad
                    }
                }
                
                // Check no polygon edges intersect rectangle edges (concave polygon fix)
                if (polygonIntersectsRectangle(polygon, left, top, right, bottom)) {
                    return false;
                }
                
                return true;
            }
            
            // Get minimum distance from rectangle edges to polygon edges
            function getMinEdgeDistance(cx, cy) {
                const corners = [
                    { x: cx - halfW, y: cy - halfH },
                    { x: cx + halfW, y: cy - halfH },
                    { x: cx - halfW, y: cy + halfH },
                    { x: cx + halfW, y: cy + halfH }
                ];
                let minDist = Infinity;
                for (const corner of corners) {
                    const dist = distanceToPolygonEdge(corner.x, corner.y, polygon);
                    if (dist < minDist) minDist = dist;
                }
                return minDist;
            }
            
            // First try centroid - this is usually the best visual position
            const centroid = getPolygonCentroid(polygon);
            if (rectangleFitsAt(centroid.x, centroid.y)) {
                // Centroid works! Use it.
                return { x: centroid.x, y: centroid.y, fits: true };
            }
            
            // Centroid doesn't fit - search for best alternative
            const bounds = getPolygonBounds(polygon);
            let bestX = null, bestY = null;
            let bestScore = -Infinity;
            
            // Sample grid to find best position where rectangle fits
            const gridSize = 30;
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const x = bounds.x + (bounds.width * (i + 0.5) / gridSize);
                    const y = bounds.y + (bounds.height * (j + 0.5) / gridSize);
                    
                    if (rectangleFitsAt(x, y)) {
                        const score = getMinEdgeDistance(x, y);
                        if (score > bestScore) {
                            bestScore = score;
                            bestX = x;
                            bestY = y;
                        }
                    }
                }
            }
            
            // If no valid position found, return centroid anyway (will be flagged)
            if (bestX === null) {
                if (DEBUG) console.warn('No position found where perfect zone fits inside polygon');
                return { x: centroid.x, y: centroid.y, fits: false };
            }
            
            return { x: bestX, y: bestY, fits: true };
        }
        
        function updateModeIndicator() {
            const indicator = document.getElementById('modeIndicator');
            const text = document.getElementById('modeText');
            
            indicator.className = 'mode-indicator';
            
            if (editorMode === 'select') {
                indicator.classList.add('mode-edit');
                text.textContent = 'Select Mode';
            } else if (editorMode === 'drawGood') {
                indicator.classList.add('mode-draw');
                text.textContent = 'Drawing Good Zone';
            } else if (editorMode === 'drawPerfect') {
                indicator.classList.add('mode-draw');
                text.textContent = 'Drawing Perfect Zone';
            }
            
            // Update button states
            document.getElementById('selectModeBtn').classList.toggle('btn-active', editorMode === 'select');
            document.getElementById('drawGoodBtn').classList.toggle('btn-active', editorMode === 'drawGood');
            document.getElementById('drawPerfectBtn').classList.toggle('btn-active', editorMode === 'drawPerfect');
            
            // Update cursor
            if (editorMode === 'select') {
                interactionCanvas.style.cursor = 'default';
            } else {
                interactionCanvas.style.cursor = 'crosshair';
            }
        }

        // ============================================
        // AUTHENTICATION
        // ============================================
        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                firebaseReady = true;
                document.getElementById('loginOverlay').classList.add('hidden');
                document.getElementById('userInfo').classList.remove('hidden');
                document.getElementById('userInfo').style.display = 'flex';
                document.getElementById('userName').textContent = user.displayName || user.email || 'User';
                showConnectionStatus(true, "Connected");
            } else {
                currentUser = null;
                firebaseReady = false;
                document.getElementById('loginOverlay').classList.remove('hidden');
                document.getElementById('userInfo').classList.add('hidden');
                showConnectionStatus(false, "Not signed in");
            }
        });
        
        document.getElementById('googleSignInBtn').addEventListener('click', async () => {
            if (DEBUG) console.log('Sign in button clicked');
            try {
                if (DEBUG) console.log('Attempting signInWithPopup...');
                const result = await signInWithPopup(auth, new GoogleAuthProvider());
                if (DEBUG) console.log('Sign in successful:', result.user.email);
            } catch (error) {
                console.error('Sign in error:', error);
                if (error.code !== 'auth/popup-closed-by-user') {
                    showToast("Sign in failed: " + error.message, "error");
                }
            }
        });
        
        document.getElementById('signOutBtn').addEventListener('click', () => firebaseSignOut(auth));

        // ============================================
        // TAB NAVIGATION
        // ============================================
        
        // Primary tab navigation
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const currentTab = document.querySelector('.tab-btn.active')?.dataset.tab;
                const targetTab = btn.dataset.tab;
                
                // If leaving sweetspot tab with unsaved changes, prompt
                if (currentTab === 'sweetspot' && targetTab !== 'sweetspot' && isDirty) {
                    if (!confirm('You have unsaved changes. Leave without saving?')) {
                        return;
                    }
                    isDirty = false;
                }
                
                // Update primary tab buttons
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Hide all primary tab content
                document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
                
                // Show target tab content
                document.getElementById(targetTab + 'Tab').classList.remove('hidden');
                
                // Show/hide Sweet Spot sub-tabs bar
                const subTabsBar = document.getElementById('sweetspotSubTabs');
                if (targetTab === 'sweetspot') {
                    subTabsBar.classList.remove('hidden');
                } else {
                    subTabsBar.classList.add('hidden');
                }
                
                // Load data based on tab
                if (targetTab === 'leaderboards') loadScoresList();
                if (targetTab === 'pictureperfect') loadPPImagesList();
            });
        });
        
        // Sweet Spot sub-tab navigation
        document.querySelectorAll('.sub-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const currentSubTab = document.querySelector('.sub-tab-btn.active')?.dataset.subtab;
                const targetSubTab = btn.dataset.subtab;
                
                // If leaving editor with unsaved changes, prompt
                if (currentSubTab === 'editor' && targetSubTab !== 'editor' && isDirty) {
                    if (!confirm('You have unsaved changes. Leave without saving?')) {
                        return;
                    }
                    isDirty = false;
                }
                
                // Update sub-tab buttons
                document.querySelectorAll('.sub-tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Hide all sub-tab content
                document.querySelectorAll('.sub-tab-content').forEach(c => c.classList.add('hidden'));
                
                // Show target sub-tab content
                document.getElementById(targetSubTab + 'SubTab').classList.remove('hidden');
                
                // Load data based on sub-tab
                if (targetSubTab === 'levels') loadLevelsList();
                if (targetSubTab === 'editor') newLevel();
            });
        });

        // ============================================
        // CANVAS SETUP
        // ============================================
        let cropCanvas, cropCtx;
        
        function initCanvases() {
            // Crop view canvas
            cropCanvas = document.getElementById('cropCanvas');
            cropCtx = cropCanvas.getContext('2d');
            
            cropCanvas.addEventListener('mousedown', handleCropMouseDown);
            cropCanvas.addEventListener('mousemove', handleCropMouseMove);
            cropCanvas.addEventListener('mouseup', handleCropMouseUp);
            cropCanvas.addEventListener('mouseleave', handleCropMouseUp);
            
            // Zone view canvases
            overlayCanvas = document.getElementById('overlayCanvas');
            overlayCtx = overlayCanvas.getContext('2d');
            interactionCanvas = document.getElementById('interactionLayer');
            
            interactionCanvas.addEventListener('mousedown', handleMouseDown);
            interactionCanvas.addEventListener('mousemove', handleMouseMove);
            interactionCanvas.addEventListener('mouseup', handleMouseUp);
            interactionCanvas.addEventListener('mouseleave', handleMouseUp);
            
            window.addEventListener('keydown', handleKeyDown);
        }
        
        // Calculate auto crop (center crop to 4:3)
        // Returns percentages that, when applied to the image, result in a 4:3 aspect ratio
        function getAutoCrop(imgWidth, imgHeight) {
            const imgAspect = imgWidth / imgHeight;
            const targetAspect = 4 / 3;
            
            let crop;
            if (imgAspect > targetAspect) {
                // Image is wider than 4:3 - crop sides, use full height
                // If height = 100%, width needs to be: (4/3) * imgHeight / imgWidth * 100
                const cropWidthPct = (targetAspect * imgHeight / imgWidth) * 100;
                crop = {
                    x: (100 - cropWidthPct) / 2,
                    y: 0,
                    width: cropWidthPct,
                    height: 100
                };
            } else {
                // Image is taller than 4:3 - crop top/bottom, use full width
                // If width = 100%, height needs to be: imgWidth / (4/3) / imgHeight * 100
                const cropHeightPct = (imgWidth / targetAspect / imgHeight) * 100;
                crop = {
                    x: 0,
                    y: (100 - cropHeightPct) / 2,
                    width: 100,
                    height: cropHeightPct
                };
            }
            
            if (DEBUG) {
                console.log(`Auto crop for ${imgWidth}√ó${imgHeight}: ${JSON.stringify(crop)}`);
                console.log(`Verifying: ${crop.width}% of ${imgWidth} = ${crop.width/100*imgWidth}, ${crop.height}% of ${imgHeight} = ${crop.height/100*imgHeight}`);
                console.log(`Aspect: ${(crop.width/100*imgWidth) / (crop.height/100*imgHeight)}`);
            }
            
            return crop;
        }
        
        // Verify and fix crop to ensure 4:3 aspect ratio
        function verifyCrop(crop, imgWidth, imgHeight) {
            const actualWidth = (crop.width / 100) * imgWidth;
            const actualHeight = (crop.height / 100) * imgHeight;
            const actualRatio = actualWidth / actualHeight;
            
            // If not close to 4:3, recalculate
            if (Math.abs(actualRatio - 4/3) > 0.01) {
                if (DEBUG) console.warn(`Crop ratio ${actualRatio} is not 4:3, recalculating...`);
                // Keep width, adjust height
                const correctHeight = actualWidth / (4/3);
                const correctHeightPct = (correctHeight / imgHeight) * 100;
                
                // Make sure it fits
                if (correctHeightPct <= 100 && crop.y + correctHeightPct <= 100) {
                    crop.height = correctHeightPct;
                } else {
                    // Keep height, adjust width
                    const correctWidth = actualHeight * (4/3);
                    const correctWidthPct = (correctWidth / imgWidth) * 100;
                    if (correctWidthPct <= 100) {
                        crop.width = correctWidthPct;
                        crop.x = Math.max(0, Math.min(crop.x, 100 - correctWidthPct));
                    }
                }
            }
            return crop;
        }
        
        // Calculate height percentage for given width to maintain 4:3
        function getHeightForWidth(widthPct, imgWidth, imgHeight) {
            // Actual width = widthPct/100 * imgWidth
            // For 4:3: actualHeight = actualWidth * 3/4
            // heightPct = actualHeight / imgHeight * 100
            const actualWidth = (widthPct / 100) * imgWidth;
            const actualHeight = actualWidth * 3 / 4;
            return (actualHeight / imgHeight) * 100;
        }
        
        // Calculate width percentage for given height to maintain 4:3  
        function getWidthForHeight(heightPct, imgWidth, imgHeight) {
            // Actual height = heightPct/100 * imgHeight
            // For 4:3: actualWidth = actualHeight * 4/3
            // widthPct = actualWidth / imgWidth * 100
            const actualHeight = (heightPct / 100) * imgHeight;
            const actualWidth = actualHeight * 4 / 3;
            return (actualWidth / imgWidth) * 100;
        }
        
        function loadImageToCanvas(imageUrl) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                loadedImage = img;
                
                // If no crop is set, or if existing crop doesn't match 4:3, recalculate
                if (!currentLevel.crop) {
                    currentLevel.crop = getAutoCrop(img.width, img.height);
                } else {
                    // Verify existing crop is actually 4:3
                    currentLevel.crop = verifyCrop(currentLevel.crop, img.width, img.height);
                }
                
                document.getElementById('cropPlaceholder').classList.add('hidden');
                document.getElementById('zonePlaceholder').classList.add('hidden');
                
                drawCropView();
                updateZoneView();
            };
            
            img.onerror = () => showToast("Failed to load image", "error");
            img.src = imageUrl;
        }
        
        function drawCropView() {
            if (!loadedImage) return;
            
            const container = document.getElementById('cropContainer');
            const maxWidth = container.clientWidth;
            const maxHeight = 500;
            
            const scale = Math.min(maxWidth / loadedImage.width, maxHeight / loadedImage.height, 1);
            const w = loadedImage.width * scale;
            const h = loadedImage.height * scale;
            
            cropCanvas.width = w;
            cropCanvas.height = h;
            
            // Draw the full image
            cropCtx.drawImage(loadedImage, 0, 0, w, h);
            
            // Darken the entire image
            cropCtx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            cropCtx.fillRect(0, 0, w, h);
            
            // Draw the crop region (clear/bright)
            const crop = currentLevel.crop;
            const cropX = (crop.x / 100) * w;
            const cropY = (crop.y / 100) * h;
            const cropW = (crop.width / 100) * w;
            const cropH = (crop.height / 100) * h;
            
            // Clear the crop region and redraw that part of the image
            cropCtx.save();
            cropCtx.beginPath();
            cropCtx.rect(cropX, cropY, cropW, cropH);
            cropCtx.clip();
            cropCtx.drawImage(loadedImage, 0, 0, w, h);
            cropCtx.restore();
            
            // Draw crop border
            cropCtx.strokeStyle = '#7BAFD4';
            cropCtx.lineWidth = 2;
            cropCtx.strokeRect(cropX, cropY, cropW, cropH);
            
            // Draw corner handles
            const handleSize = 10;
            cropCtx.fillStyle = '#7BAFD4';
            
            // Corners
            cropCtx.fillRect(cropX - handleSize/2, cropY - handleSize/2, handleSize, handleSize);
            cropCtx.fillRect(cropX + cropW - handleSize/2, cropY - handleSize/2, handleSize, handleSize);
            cropCtx.fillRect(cropX - handleSize/2, cropY + cropH - handleSize/2, handleSize, handleSize);
            cropCtx.fillRect(cropX + cropW - handleSize/2, cropY + cropH - handleSize/2, handleSize, handleSize);
            
            // Edge handles
            cropCtx.fillRect(cropX + cropW/2 - handleSize/2, cropY - handleSize/2, handleSize, handleSize);
            cropCtx.fillRect(cropX + cropW/2 - handleSize/2, cropY + cropH - handleSize/2, handleSize, handleSize);
            cropCtx.fillRect(cropX - handleSize/2, cropY + cropH/2 - handleSize/2, handleSize, handleSize);
            cropCtx.fillRect(cropX + cropW - handleSize/2, cropY + cropH/2 - handleSize/2, handleSize, handleSize);
            
            // Draw aspect ratio label - show ACTUAL ratio for debugging
            const actualCropWidth = (crop.width / 100) * loadedImage.width;
            const actualCropHeight = (crop.height / 100) * loadedImage.height;
            const actualRatio = actualCropWidth / actualCropHeight;
            const ratioText = `${actualRatio.toFixed(2)} (target: 1.33)`;
            
            cropCtx.fillStyle = actualRatio > 1.30 && actualRatio < 1.36 ? 'rgba(123, 175, 212, 0.9)' : 'rgba(231, 76, 60, 0.9)';
            cropCtx.font = "bold 14px 'Century Gothic', sans-serif";
            cropCtx.fillText(ratioText, cropX + 8, cropY + 20);
            
            // Also show image dimensions
            cropCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            cropCtx.font = "12px 'Century Gothic', sans-serif";
            cropCtx.fillText(`Image: ${loadedImage.width}√ó${loadedImage.height}`, cropX + 8, cropY + 38);
            cropCtx.fillText(`Crop: ${Math.round(actualCropWidth)}√ó${Math.round(actualCropHeight)}`, cropX + 8, cropY + 54);
        }
        
        function updateZoneView() {
            if (!loadedImage || !currentLevel.crop) return;
            
            const container = document.getElementById('zoneContainer');
            const crop = currentLevel.crop;
            
            // Create a cropped version of the image as a data URL
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            const srcX = (crop.x / 100) * loadedImage.width;
            const srcY = (crop.y / 100) * loadedImage.height;
            const srcW = (crop.width / 100) * loadedImage.width;
            const srcH = (crop.height / 100) * loadedImage.height;
            
            tempCanvas.width = srcW;
            tempCanvas.height = srcH;
            tempCtx.drawImage(loadedImage, srcX, srcY, srcW, srcH, 0, 0, srcW, srcH);
            
            // Set as background
            container.style.backgroundImage = `url('${tempCanvas.toDataURL()}')`;
            
            // Size the overlay canvases
            const rect = container.getBoundingClientRect();
            overlayCanvas.width = interactionCanvas.width = rect.width;
            overlayCanvas.height = interactionCanvas.height = rect.height;
            
            // Measure text size now that canvas is ready
            measureTextDimensions();
            
            redrawOverlay();
        }
        
        function redrawOverlay(mouseX, mouseY) {
            if (!loadedImage) return;
            
            // Re-check container size in case of resize
            const container = document.getElementById('zoneContainer');
            const rect = container.getBoundingClientRect();
            
            if (overlayCanvas.width !== rect.width || overlayCanvas.height !== rect.height) {
                overlayCanvas.width = interactionCanvas.width = rect.width;
                overlayCanvas.height = interactionCanvas.height = rect.height;
                measureTextDimensions(); // Re-measure on resize
            }
            
            const w = overlayCanvas.width;
            const h = overlayCanvas.height;
            overlayCtx.clearRect(0, 0, w, h);
            
            // If zones are hidden, only draw text previews
            if (!zonesVisible) {
                currentLevel.zoneSets.forEach(set => {
                    if (hiddenSets.has(set.id)) return; // Skip hidden sets
                    if (set.perfectZone) {
                        drawTextPreview(set.perfectZone, set.color);
                    }
                });
                return;
            }
            
            // Draw non-selected sets first (faded)
            currentLevel.zoneSets.forEach(set => {
                if (set.id === selectedSetId) return; // Skip selected set for now
                if (hiddenSets.has(set.id)) return; // Skip hidden sets
                
                // Draw faded good zones
                set.goodZones.forEach((zone, idx) => {
                    drawZone(zone, 'good', set.color, false, true); // true = faded
                });
                
                // Draw faded perfect zone
                if (set.perfectZone) {
                    drawZone(set.perfectZone, 'perfect', set.color, false, true);
                }
            });
            
            // Draw selected set on top (full opacity) - unless hidden
            const selectedSet = currentLevel.zoneSets.find(s => s.id === selectedSetId);
            if (selectedSet && !hiddenSets.has(selectedSet.id)) {
                // Draw good zones
                selectedSet.goodZones.forEach((zone, idx) => {
                    drawZone(zone, 'good', selectedSet.color, selectedZoneType === 'good' && selectedZoneIndex === idx, false);
                });
                
                // Draw perfect zone
                if (selectedSet.perfectZone) {
                    drawZone(selectedSet.perfectZone, 'perfect', selectedSet.color, selectedZoneType === 'perfect', false);
                    
                    // Draw text preview in perfect zone
                    drawTextPreview(selectedSet.perfectZone, selectedSet.color);
                    
                    // Draw distance guides if selected
                    if (selectedZoneType === 'perfect' && selectedSet.goodZones.length > 0) {
                        drawDistanceGuides(selectedSet.perfectZone, selectedSet.goodZones);
                    }
                }
            }
            
            // Draw polygon being created
            if (editorMode === 'drawGood' && polygonPoints.length > 0) {
                drawTempPolygon(polygonPoints, mouseX, mouseY);
            }
            
            // Draw temp rectangle while drawing perfect zone
            if (tempZone && editorMode === 'drawPerfect') {
                const color = 'rgba(59, 130, 246, 0.5)';
                overlayCtx.fillStyle = color;
                overlayCtx.strokeStyle = '#fff';
                overlayCtx.lineWidth = 2;
                const rect = percentToPixel(tempZone);
                overlayCtx.fillRect(rect.x, rect.y, rect.w, rect.h);
                overlayCtx.strokeRect(rect.x, rect.y, rect.w, rect.h);
            }
        }
        
        function drawZone(zone, type, textColor, isSelected, isFaded = false) {
            const baseColor = type === 'good' ? 'rgba(74, 222, 128,' : 'rgba(59, 130, 246,';
            
            // Faded zones are much more transparent
            let fillAlpha, strokeAlpha;
            if (isFaded) {
                fillAlpha = '0.1)';
                strokeAlpha = '0.3)';
            } else if (isSelected) {
                fillAlpha = '0.5)';
                strokeAlpha = '1)';
            } else {
                fillAlpha = '0.3)';
                strokeAlpha = '0.7)';
            }
            
            overlayCtx.fillStyle = baseColor + fillAlpha;
            
            if (isFaded) {
                overlayCtx.strokeStyle = 'rgba(128, 128, 128, 0.3)';
            } else {
                overlayCtx.strokeStyle = isSelected ? '#fff' : (textColor === 'white' ? 'rgba(255,255,255,0.7)' : 'rgba(0,0,0,0.7)');
            }
            
            overlayCtx.lineWidth = isSelected ? 3 : (isFaded ? 1 : 2);
            overlayCtx.setLineDash(isSelected ? [] : [5, 5]);
            
            if (type === 'good' && zone.points) {
                // Draw polygon
                const pixelPoints = polygonToPixels(zone);
                
                overlayCtx.beginPath();
                overlayCtx.moveTo(pixelPoints[0].x, pixelPoints[0].y);
                for (let i = 1; i < pixelPoints.length; i++) {
                    overlayCtx.lineTo(pixelPoints[i].x, pixelPoints[i].y);
                }
                overlayCtx.closePath();
                overlayCtx.fill();
                overlayCtx.stroke();
                
                // Draw vertex handles if selected (not faded)
                if (isSelected && !isFaded) {
                    drawPolygonVertices(pixelPoints);
                }
                
                // Label at first point (skip for faded)
                if (!isFaded) {
                    overlayCtx.fillStyle = textColor === 'white' ? '#fff' : '#000';
                    overlayCtx.font = "bold 11px 'Century Gothic', sans-serif";
                    overlayCtx.fillText('GOOD', pixelPoints[0].x + 4, pixelPoints[0].y + 14);
                }
            } else {
                // Draw rectangle (for perfect zones and legacy good zones)
                const rect = percentToPixel(zone);
                
                overlayCtx.fillRect(rect.x, rect.y, rect.w, rect.h);
                overlayCtx.strokeRect(rect.x, rect.y, rect.w, rect.h);
                
                // Draw resize handles if selected (not faded)
                if (isSelected && !isFaded) {
                    drawResizeHandles(rect);
                }
                
                // Label (skip for faded)
                if (!isFaded) {
                    overlayCtx.fillStyle = textColor === 'white' ? '#fff' : '#000';
                    overlayCtx.font = "bold 11px 'Century Gothic', sans-serif";
                    overlayCtx.fillText(type === 'good' ? 'GOOD' : 'PERFECT', rect.x + 4, rect.y + 14);
                }
            }
            
            overlayCtx.setLineDash([]);
        }
        
        function drawPolygonVertices(pixelPoints) {
            const handleSize = 10;
            
            pixelPoints.forEach((p, idx) => {
                // Highlight selected vertex
                const isVertexSelected = selectedVertexIndex === idx;
                
                overlayCtx.fillStyle = isVertexSelected ? '#7BAFD4' : '#fff';
                overlayCtx.strokeStyle = '#000';
                overlayCtx.lineWidth = 2;
                
                overlayCtx.beginPath();
                overlayCtx.arc(p.x, p.y, handleSize/2, 0, Math.PI * 2);
                overlayCtx.fill();
                overlayCtx.stroke();
                
                // Draw vertex number
                overlayCtx.fillStyle = '#000';
                overlayCtx.font = "bold 9px sans-serif";
                overlayCtx.textAlign = 'center';
                overlayCtx.textBaseline = 'middle';
                overlayCtx.fillText(String(idx + 1), p.x, p.y);
                overlayCtx.textAlign = 'left';
                overlayCtx.textBaseline = 'alphabetic';
            });
        }
        
        function drawResizeHandles(rect) {
            const handleSize = 8;
            const handles = getHandlePositions(rect);
            
            overlayCtx.fillStyle = '#fff';
            overlayCtx.strokeStyle = '#000';
            overlayCtx.lineWidth = 1;
            
            handles.forEach(h => {
                overlayCtx.fillRect(h.x - handleSize/2, h.y - handleSize/2, handleSize, handleSize);
                overlayCtx.strokeRect(h.x - handleSize/2, h.y - handleSize/2, handleSize, handleSize);
            });
        }
        
        function getHandlePositions(rect) {
            return [
                { id: 'nw', x: rect.x, y: rect.y },
                { id: 'n', x: rect.x + rect.w/2, y: rect.y },
                { id: 'ne', x: rect.x + rect.w, y: rect.y },
                { id: 'e', x: rect.x + rect.w, y: rect.y + rect.h/2 },
                { id: 'se', x: rect.x + rect.w, y: rect.y + rect.h },
                { id: 's', x: rect.x + rect.w/2, y: rect.y + rect.h },
                { id: 'sw', x: rect.x, y: rect.y + rect.h },
                { id: 'w', x: rect.x, y: rect.y + rect.h/2 }
            ];
        }
        
        // Draw polygon being created
        function drawTempPolygon(points, mouseX, mouseY) {
            if (points.length === 0) return;
            
            const pixelPoints = points.map(p => ({
                x: (p.x / 100) * overlayCanvas.width,
                y: (p.y / 100) * overlayCanvas.height
            }));
            
            overlayCtx.strokeStyle = '#7BAFD4';
            overlayCtx.lineWidth = 2;
            overlayCtx.setLineDash([]);
            
            // Draw completed segments
            overlayCtx.beginPath();
            overlayCtx.moveTo(pixelPoints[0].x, pixelPoints[0].y);
            for (let i = 1; i < pixelPoints.length; i++) {
                overlayCtx.lineTo(pixelPoints[i].x, pixelPoints[i].y);
            }
            
            // Line to current mouse position
            if (mouseX !== undefined) {
                overlayCtx.lineTo(mouseX, mouseY);
                
                // Dashed line back to start if near closing
                const startDist = Math.hypot(mouseX - pixelPoints[0].x, mouseY - pixelPoints[0].y);
                if (startDist < 20 && points.length >= 3) {
                    overlayCtx.setLineDash([5, 5]);
                    overlayCtx.lineTo(pixelPoints[0].x, pixelPoints[0].y);
                }
            }
            
            overlayCtx.stroke();
            overlayCtx.setLineDash([]);
            
            // Draw vertices
            pixelPoints.forEach((p, idx) => {
                overlayCtx.fillStyle = idx === 0 && points.length >= 3 ? '#7BAFD4' : '#fff';
                overlayCtx.strokeStyle = '#000';
                overlayCtx.lineWidth = 2;
                overlayCtx.beginPath();
                overlayCtx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                overlayCtx.fill();
                overlayCtx.stroke();
            });
            
            // Instruction text
            overlayCtx.fillStyle = 'rgba(0,0,0,0.7)';
            overlayCtx.fillRect(10, overlayCanvas.height - 35, 280, 25);
            overlayCtx.fillStyle = '#fff';
            overlayCtx.font = "12px 'Century Gothic', sans-serif";
            if (points.length < 3) {
                overlayCtx.fillText(`Click to add points (${points.length}/3 minimum)`, 15, overlayCanvas.height - 18);
            } else {
                overlayCtx.fillText('Click near start point to close, or keep adding', 15, overlayCanvas.height - 18);
            }
        }
        
        function drawTextPreview(zone, textColor) {
            const rect = percentToPixel(zone);
            const centerX = rect.x + rect.w / 2;
            const centerY = rect.y + rect.h / 2;
            
            // Fixed text size matching game (3.5rem ‚âà 56px, but scale to canvas)
            // The game container and admin canvas should show text at same relative size
            const canvasHeight = overlayCanvas.height;
            const fontSize = canvasHeight * 0.09; // ~9% of height matches 3.5rem in game
            
            overlayCtx.fillStyle = textColor === 'white' ? '#fff' : '#000';
            overlayCtx.font = `bold ${fontSize}px 'Century Gothic', sans-serif`;
            overlayCtx.textAlign = 'center';
            overlayCtx.textBaseline = 'middle';
            
            // Draw shadow
            overlayCtx.shadowColor = textColor === 'white' ? 'rgba(0,0,0,0.9)' : 'rgba(255,255,255,0.9)';
            overlayCtx.shadowBlur = 6;
            overlayCtx.shadowOffsetX = 2;
            overlayCtx.shadowOffsetY = 2;
            
            // Two lines of title text
            const lineHeight = fontSize * 1.15;
            overlayCtx.fillText('Read', centerX, centerY - lineHeight/2);
            overlayCtx.fillText('This Text', centerX, centerY + lineHeight/2);
            
            // Draw bounding box using the SAME dimensions as perfect zone
            // Convert percentages to pixels
            const boxWidth = (TEXT_WIDTH_PERCENT / 100) * overlayCanvas.width;
            const boxHeight = (TEXT_HEIGHT_PERCENT / 100) * overlayCanvas.height;
            
            overlayCtx.shadowColor = 'transparent';
            overlayCtx.strokeStyle = 'rgba(255, 255, 0, 0.8)'; // Yellow for visibility
            overlayCtx.lineWidth = 2;
            overlayCtx.setLineDash([4, 4]);
            overlayCtx.strokeRect(
                centerX - boxWidth/2,
                centerY - boxHeight/2,
                boxWidth,
                boxHeight
            );
            overlayCtx.setLineDash([]);
            
            overlayCtx.textAlign = 'left';
            overlayCtx.textBaseline = 'alphabetic';
        }
        
        function drawDistanceGuides(perfectZone, goodZones) {
            const pRect = percentToPixel(perfectZone);
            const pCenterX = pRect.x + pRect.w / 2;
            const pCenterY = pRect.y + pRect.h / 2;
            
            // Convert perfect zone center to percentage for polygon check
            const pCenterPct = pixelToPercent(pCenterX, pCenterY);
            
            goodZones.forEach(goodZone => {
                if (goodZone.points) {
                    // Polygon - check if perfect center is inside
                    if (pointInPolygon(pCenterPct.x, pCenterPct.y, goodZone)) {
                        drawPolygonDistanceGuides(pRect, goodZone);
                    }
                } else {
                    // Legacy rectangle
                    const gRect = percentToPixel(goodZone);
                    
                    if (pCenterX >= gRect.x && pCenterX <= gRect.x + gRect.w &&
                        pCenterY >= gRect.y && pCenterY <= gRect.y + gRect.h) {
                        drawRectDistanceGuides(pRect, gRect);
                    }
                }
            });
        }
        
        function drawRectDistanceGuides(pRect, gRect) {
            const pCenterX = pRect.x + pRect.w / 2;
            const pCenterY = pRect.y + pRect.h / 2;
            
            overlayCtx.strokeStyle = 'rgba(123, 175, 212, 0.8)';
            overlayCtx.lineWidth = 1;
            overlayCtx.setLineDash([3, 3]);
            
            // Left distance
            const leftDist = pRect.x - gRect.x;
            overlayCtx.beginPath();
            overlayCtx.moveTo(gRect.x, pCenterY);
            overlayCtx.lineTo(pRect.x, pCenterY);
            overlayCtx.stroke();
            drawDistanceLabel(gRect.x + leftDist/2, pCenterY - 10, Math.round(leftDist) + 'px');
            
            // Right distance
            const rightDist = (gRect.x + gRect.w) - (pRect.x + pRect.w);
            overlayCtx.beginPath();
            overlayCtx.moveTo(pRect.x + pRect.w, pCenterY);
            overlayCtx.lineTo(gRect.x + gRect.w, pCenterY);
            overlayCtx.stroke();
            drawDistanceLabel(pRect.x + pRect.w + rightDist/2, pCenterY - 10, Math.round(rightDist) + 'px');
            
            // Top distance
            const topDist = pRect.y - gRect.y;
            overlayCtx.beginPath();
            overlayCtx.moveTo(pCenterX, gRect.y);
            overlayCtx.lineTo(pCenterX, pRect.y);
            overlayCtx.stroke();
            drawDistanceLabel(pCenterX + 10, gRect.y + topDist/2, Math.round(topDist) + 'px');
            
            // Bottom distance
            const bottomDist = (gRect.y + gRect.h) - (pRect.y + pRect.h);
            overlayCtx.beginPath();
            overlayCtx.moveTo(pCenterX, pRect.y + pRect.h);
            overlayCtx.lineTo(pCenterX, gRect.y + gRect.h);
            overlayCtx.stroke();
            drawDistanceLabel(pCenterX + 10, pRect.y + pRect.h + bottomDist/2, Math.round(bottomDist) + 'px');
            
            overlayCtx.setLineDash([]);
        }
        
        function drawPolygonDistanceGuides(pRect, polygon) {
            const pCenterX = pRect.x + pRect.w / 2;
            const pCenterY = pRect.y + pRect.h / 2;
            
            // Get pixel coordinates of polygon
            const pixelPoints = polygonToPixels(polygon);
            
            overlayCtx.strokeStyle = 'rgba(123, 175, 212, 0.8)';
            overlayCtx.lineWidth = 1;
            overlayCtx.setLineDash([3, 3]);
            
            // Find distances from each edge of perfect zone to nearest polygon edge
            // Left edge
            const leftEdge = findNearestPolygonIntersection(pRect.x, pCenterY, -1, 0, pixelPoints);
            if (leftEdge) {
                const leftDist = pRect.x - leftEdge.x;
                overlayCtx.beginPath();
                overlayCtx.moveTo(leftEdge.x, pCenterY);
                overlayCtx.lineTo(pRect.x, pCenterY);
                overlayCtx.stroke();
                drawDistanceLabel(leftEdge.x + leftDist/2, pCenterY - 10, Math.round(leftDist) + 'px');
            }
            
            // Right edge
            const rightEdge = findNearestPolygonIntersection(pRect.x + pRect.w, pCenterY, 1, 0, pixelPoints);
            if (rightEdge) {
                const rightDist = rightEdge.x - (pRect.x + pRect.w);
                overlayCtx.beginPath();
                overlayCtx.moveTo(pRect.x + pRect.w, pCenterY);
                overlayCtx.lineTo(rightEdge.x, pCenterY);
                overlayCtx.stroke();
                drawDistanceLabel(pRect.x + pRect.w + rightDist/2, pCenterY - 10, Math.round(rightDist) + 'px');
            }
            
            // Top edge
            const topEdge = findNearestPolygonIntersection(pCenterX, pRect.y, 0, -1, pixelPoints);
            if (topEdge) {
                const topDist = pRect.y - topEdge.y;
                overlayCtx.beginPath();
                overlayCtx.moveTo(pCenterX, topEdge.y);
                overlayCtx.lineTo(pCenterX, pRect.y);
                overlayCtx.stroke();
                drawDistanceLabel(pCenterX + 10, topEdge.y + topDist/2, Math.round(topDist) + 'px');
            }
            
            // Bottom edge
            const bottomEdge = findNearestPolygonIntersection(pCenterX, pRect.y + pRect.h, 0, 1, pixelPoints);
            if (bottomEdge) {
                const bottomDist = bottomEdge.y - (pRect.y + pRect.h);
                overlayCtx.beginPath();
                overlayCtx.moveTo(pCenterX, pRect.y + pRect.h);
                overlayCtx.lineTo(pCenterX, bottomEdge.y);
                overlayCtx.stroke();
                drawDistanceLabel(pCenterX + 10, pRect.y + pRect.h + bottomDist/2, Math.round(bottomDist) + 'px');
            }
            
            overlayCtx.setLineDash([]);
        }
        
        // Find where a ray from point (px, py) in direction (dx, dy) intersects the polygon
        function findNearestPolygonIntersection(px, py, dx, dy, pixelPoints) {
            let nearestDist = Infinity;
            let nearestPoint = null;
            
            for (let i = 0; i < pixelPoints.length; i++) {
                const j = (i + 1) % pixelPoints.length;
                const x1 = pixelPoints[i].x, y1 = pixelPoints[i].y;
                const x2 = pixelPoints[j].x, y2 = pixelPoints[j].y;
                
                // Ray-line segment intersection
                const intersection = raySegmentIntersection(px, py, dx, dy, x1, y1, x2, y2);
                if (intersection) {
                    const dist = Math.hypot(intersection.x - px, intersection.y - py);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestPoint = intersection;
                    }
                }
            }
            
            return nearestPoint;
        }
        
        function raySegmentIntersection(px, py, dx, dy, x1, y1, x2, y2) {
            const ex = x2 - x1;
            const ey = y2 - y1;
            
            const denom = dx * ey - dy * ex;
            if (Math.abs(denom) < 0.0001) return null; // Parallel
            
            const t = ((x1 - px) * ey - (y1 - py) * ex) / denom;
            const u = ((x1 - px) * dy - (y1 - py) * dx) / denom;
            
            if (t >= 0 && u >= 0 && u <= 1) {
                return {
                    x: px + t * dx,
                    y: py + t * dy
                };
            }
            
            return null;
        }
        
        function drawDistanceLabel(x, y, text) {
            overlayCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            const metrics = overlayCtx.measureText(text);
            overlayCtx.fillRect(x - metrics.width/2 - 4, y - 8, metrics.width + 8, 16);
            
            overlayCtx.fillStyle = '#7BAFD4';
            overlayCtx.font = "bold 10px 'Century Gothic', sans-serif";
            overlayCtx.textAlign = 'center';
            overlayCtx.textBaseline = 'middle';
            overlayCtx.fillText(text, x, y);
            overlayCtx.textAlign = 'left';
            overlayCtx.textBaseline = 'alphabetic';
        }
        
        // ============================================
        // CROP MOUSE HANDLERS
        // ============================================
        let cropDragHandle = null;
        let cropDragStart = null;
        
        function getCropHandleAt(x, y) {
            if (!loadedImage || !currentLevel.crop) return null;
            
            const w = cropCanvas.width;
            const h = cropCanvas.height;
            const crop = currentLevel.crop;
            
            const cropX = (crop.x / 100) * w;
            const cropY = (crop.y / 100) * h;
            const cropW = (crop.width / 100) * w;
            const cropH = (crop.height / 100) * h;
            
            const handleSize = 12;
            
            // Check corners first
            if (Math.abs(x - cropX) < handleSize && Math.abs(y - cropY) < handleSize) return 'nw';
            if (Math.abs(x - (cropX + cropW)) < handleSize && Math.abs(y - cropY) < handleSize) return 'ne';
            if (Math.abs(x - cropX) < handleSize && Math.abs(y - (cropY + cropH)) < handleSize) return 'sw';
            if (Math.abs(x - (cropX + cropW)) < handleSize && Math.abs(y - (cropY + cropH)) < handleSize) return 'se';
            
            // Check edges
            if (Math.abs(x - (cropX + cropW/2)) < handleSize && Math.abs(y - cropY) < handleSize) return 'n';
            if (Math.abs(x - (cropX + cropW/2)) < handleSize && Math.abs(y - (cropY + cropH)) < handleSize) return 's';
            if (Math.abs(x - cropX) < handleSize && Math.abs(y - (cropY + cropH/2)) < handleSize) return 'w';
            if (Math.abs(x - (cropX + cropW)) < handleSize && Math.abs(y - (cropY + cropH/2)) < handleSize) return 'e';
            
            // Check if inside (for move)
            if (x >= cropX && x <= cropX + cropW && y >= cropY && y <= cropY + cropH) return 'move';
            
            return null;
        }
        
        function handleCropMouseDown(e) {
            if (!loadedImage) return;
            
            const rect = cropCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            cropDragHandle = getCropHandleAt(x, y);
            if (cropDragHandle) {
                cropDragStart = {
                    x, y,
                    crop: { ...currentLevel.crop }
                };
                cropCanvas.style.cursor = cropDragHandle === 'move' ? 'grabbing' : 'crosshair';
            }
        }
        
        function handleCropMouseMove(e) {
            const rect = cropCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (!cropDragStart) {
                // Just update cursor
                const handle = getCropHandleAt(x, y);
                if (handle === 'move') cropCanvas.style.cursor = 'grab';
                else if (handle === 'nw' || handle === 'se') cropCanvas.style.cursor = 'nwse-resize';
                else if (handle === 'ne' || handle === 'sw') cropCanvas.style.cursor = 'nesw-resize';
                else if (handle === 'n' || handle === 's') cropCanvas.style.cursor = 'ns-resize';
                else if (handle === 'e' || handle === 'w') cropCanvas.style.cursor = 'ew-resize';
                else cropCanvas.style.cursor = 'default';
                return;
            }
            
            const w = cropCanvas.width;
            const h = cropCanvas.height;
            const imgW = loadedImage.width;
            const imgH = loadedImage.height;
            const original = cropDragStart.crop;
            
            // Convert to percentages
            const dx = ((x - cropDragStart.x) / w) * 100;
            const dy = ((y - cropDragStart.y) / h) * 100;
            
            let newX = original.x;
            let newY = original.y;
            let newW = original.width;
            let newH = original.height;
            
            const minWidthPct = 20; // Minimum 20% of image width
            
            if (cropDragHandle === 'move') {
                newX = Math.max(0, Math.min(100 - original.width, original.x + dx));
                newY = Math.max(0, Math.min(100 - original.height, original.y + dy));
            } else {
                // For resizing, we need to maintain 4:3 aspect ratio
                // The key insight: we adjust width and then calculate the corresponding height
                
                if (cropDragHandle === 'e' || cropDragHandle === 'ne' || cropDragHandle === 'se') {
                    // Dragging east edge - adjust width
                    newW = Math.max(minWidthPct, Math.min(100 - original.x, original.width + dx));
                    newH = getHeightForWidth(newW, imgW, imgH);
                    
                    // Adjust Y for north handles
                    if (cropDragHandle === 'ne') {
                        newY = original.y + original.height - newH;
                    }
                }
                else if (cropDragHandle === 'w' || cropDragHandle === 'nw' || cropDragHandle === 'sw') {
                    // Dragging west edge
                    const rightEdge = original.x + original.width;
                    newX = Math.max(0, Math.min(rightEdge - minWidthPct, original.x + dx));
                    newW = rightEdge - newX;
                    newH = getHeightForWidth(newW, imgW, imgH);
                    
                    // Adjust Y for north handles
                    if (cropDragHandle === 'nw') {
                        newY = original.y + original.height - newH;
                    }
                }
                else if (cropDragHandle === 'n') {
                    // Dragging north edge - adjust height, calculate width
                    const bottomEdge = original.y + original.height;
                    const minHeightPct = getHeightForWidth(minWidthPct, imgW, imgH);
                    newY = Math.max(0, Math.min(bottomEdge - minHeightPct, original.y + dy));
                    newH = bottomEdge - newY;
                    newW = getWidthForHeight(newH, imgW, imgH);
                    // Center horizontally
                    newX = original.x + (original.width - newW) / 2;
                }
                else if (cropDragHandle === 's') {
                    // Dragging south edge
                    const minHeightPct = getHeightForWidth(minWidthPct, imgW, imgH);
                    newH = Math.max(minHeightPct, Math.min(100 - original.y, original.height + dy));
                    newW = getWidthForHeight(newH, imgW, imgH);
                    // Center horizontally
                    newX = original.x + (original.width - newW) / 2;
                }
                
                // Clamp to image bounds
                if (newX < 0) {
                    newX = 0;
                }
                if (newY < 0) {
                    newY = 0;
                }
                if (newX + newW > 100) {
                    newW = 100 - newX;
                    newH = getHeightForWidth(newW, imgW, imgH);
                }
                if (newY + newH > 100) {
                    newH = 100 - newY;
                    newW = getWidthForHeight(newH, imgW, imgH);
                }
            }
            
            currentLevel.crop = { x: newX, y: newY, width: newW, height: newH };
            drawCropView();
        }
        
        function handleCropMouseUp() {
            if (cropDragStart) {
                cropDragStart = null;
                cropDragHandle = null;
                updateZoneView(); // Update the zone view with new crop
            }
        }
        
        function percentToPixel(zone) {
            return {
                x: (zone.x / 100) * overlayCanvas.width,
                y: (zone.y / 100) * overlayCanvas.height,
                w: (zone.width / 100) * overlayCanvas.width,
                h: (zone.height / 100) * overlayCanvas.height
            };
        }

        // ============================================
        // MOUSE HANDLERS
        // ============================================
        function handleMouseDown(e) {
            if (!loadedImage) return;
            
            const rect = interactionCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const pct = pixelToPercent(x, y);
            
            if (editorMode === 'drawGood') {
                // Polygon drawing mode - add point on click
                if (!selectedSetId) {
                    showToast('Select or create a Zone Set first', 'error');
                    return;
                }
                
                // Check if clicking near start point to close polygon
                if (polygonPoints.length >= 3) {
                    const startPx = {
                        x: (polygonPoints[0].x / 100) * overlayCanvas.width,
                        y: (polygonPoints[0].y / 100) * overlayCanvas.height
                    };
                    if (Math.hypot(x - startPx.x, y - startPx.y) < 20) {
                        // Close the polygon
                        finishPolygon();
                        return;
                    }
                }
                
                // Add point
                polygonPoints.push({ x: pct.x, y: pct.y });
                redrawOverlay(x, y);
                return;
            }
            
            if (editorMode === 'drawPerfect') {
                // Rectangle drawing mode for perfect zones
                if (!selectedSetId) {
                    showToast('Select or create a Zone Set first', 'error');
                    return;
                }
                isDrawing = true;
                drawStart = { x, y };
                tempZone = null;
                return;
            }
            
            if (editorMode === 'select') {
                // When zones are hidden, only allow moving the perfect zone (text)
                if (!zonesVisible) {
                    if (selectedSetId) {
                        const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
                        if (set && set.perfectZone) {
                            const zone = set.perfectZone;
                            const zoneRect = percentToPixel(zone);
                            if (x >= zoneRect.x && x <= zoneRect.x + zoneRect.w &&
                                y >= zoneRect.y && y <= zoneRect.y + zoneRect.h) {
                                saveUndoState('text move');
                                dragHandle = 'move';
                                drawStart = { x, y, zone: { ...zone } };
                                selectedZoneType = 'perfect';
                                selectedZoneIndex = null;
                                return;
                            }
                        }
                    }
                    return;
                }
                
                // FIRST: Check if clicking on the perfect zone (takes priority)
                if (selectedSetId) {
                    const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
                    if (set && set.perfectZone) {
                        const zone = set.perfectZone;
                        const zoneRect = percentToPixel(zone);
                        const handles = getHandlePositions(zoneRect);
                        
                        // Check handles
                        for (const h of handles) {
                            if (Math.abs(x - h.x) < 8 && Math.abs(y - h.y) < 8) {
                                saveUndoState('perfect zone resize');
                                dragHandle = h.id;
                                drawStart = { x, y, zone: { ...zone } };
                                selectedZoneType = 'perfect';
                                selectedZoneIndex = null;
                                redrawOverlay();
                                return;
                            }
                        }
                        
                        // Check if inside perfect zone for move/select
                        if (x >= zoneRect.x && x <= zoneRect.x + zoneRect.w &&
                            y >= zoneRect.y && y <= zoneRect.y + zoneRect.h) {
                            saveUndoState('perfect zone move');
                            dragHandle = 'move';
                            drawStart = { x, y, zone: { ...zone } };
                            selectedZoneType = 'perfect';
                            selectedZoneIndex = null;
                            redrawOverlay();
                            return;
                        }
                    }
                }
                
                // SECOND: Check if clicking on a polygon vertex
                if (selectedSetId && selectedZoneType === 'good' && selectedZoneIndex !== null) {
                    const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
                    if (set) {
                        const zone = set.goodZones[selectedZoneIndex];
                        if (zone && zone.points) {
                            const pixelPoints = polygonToPixels(zone);
                            for (let i = 0; i < pixelPoints.length; i++) {
                                if (Math.hypot(x - pixelPoints[i].x, y - pixelPoints[i].y) < 10) {
                                    saveUndoState('vertex move');
                                    selectedVertexIndex = i;
                                    dragHandle = 'vertex';
                                    drawStart = { 
                                        x, y, 
                                        points: zone.points.map(p => ({...p})),
                                        originalPoint: { ...zone.points[i] } // For shift constraint
                                    };
                                    redrawOverlay();
                                    return;
                                }
                            }
                        }
                    }
                }
                
                // THIRD: Check if clicking inside a polygon (for move)
                if (selectedSetId && selectedZoneType === 'good' && selectedZoneIndex !== null) {
                    const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
                    if (set) {
                        const zone = set.goodZones[selectedZoneIndex];
                        if (zone && zone.points && pointInPolygon(pct.x, pct.y, zone)) {
                            saveUndoState('polygon move');
                            dragHandle = 'movePolygon';
                            drawStart = { x, y, points: zone.points.map(p => ({...p})) };
                            return;
                        }
                    }
                }
                
                // FOURTH: Check if clicking on any zone to select it
                const clicked = findZoneAt(x, y);
                if (clicked) {
                    selectedSetId = clicked.setId;
                    selectedZoneType = clicked.type;
                    selectedZoneIndex = clicked.index;
                    selectedVertexIndex = null;
                    updateZoneSetsList();
                    updateZoneSetEditor();
                    redrawOverlay();
                } else {
                    // Clicked outside all zones - only deselect zone, not set
                    selectedZoneType = null;
                    selectedZoneIndex = null;
                    selectedVertexIndex = null;
                    redrawOverlay();
                }
            }
        }
        
        function finishPolygon() {
            if (DEBUG) console.log('finishPolygon called, points:', polygonPoints.length);
            if (polygonPoints.length < 3) {
                showToast('Need at least 3 points for a polygon', 'error');
                polygonPoints = [];
                redrawOverlay();
                return;
            }
            
            const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
            if (DEBUG) console.log('Adding polygon to set:', selectedSetId, 'with points:', [...polygonPoints]);
            if (set) {
                set.goodZones.push({ points: [...polygonPoints] });
                selectedZoneType = 'good';
                selectedZoneIndex = set.goodZones.length - 1;
                if (DEBUG) console.log('Polygon added, new goodZones count:', set.goodZones.length);
                updateSetZonesList();
            }
            
            polygonPoints = [];
            editorMode = 'select';
            if (DEBUG) console.log('Mode changed to select, polygonPoints cleared');
            updateModeIndicator();
            redrawOverlay();
        }
        
        function handleMouseMove(e) {
            if (!loadedImage) return;
            
            const rect = interactionCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const pct = pixelToPercent(x, y);
            
            // Drawing polygon - update preview
            if (editorMode === 'drawGood' && polygonPoints.length > 0) {
                redrawOverlay(x, y);
                return;
            }
            
            // Dragging vertex
            if (dragHandle === 'vertex' && drawStart && selectedVertexIndex !== null) {
                const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
                if (set && set.goodZones[selectedZoneIndex]) {
                    let newX = Math.max(0, Math.min(100, pct.x));
                    let newY = Math.max(0, Math.min(100, pct.y));
                    
                    // Shift key constrains to horizontal or vertical
                    if (e.shiftKey && drawStart.originalPoint) {
                        const dx = Math.abs(newX - drawStart.originalPoint.x);
                        const dy = Math.abs(newY - drawStart.originalPoint.y);
                        if (dx > dy) {
                            newY = drawStart.originalPoint.y; // Horizontal lock
                        } else {
                            newX = drawStart.originalPoint.x; // Vertical lock
                        }
                    }
                    
                    set.goodZones[selectedZoneIndex].points[selectedVertexIndex] = { x: newX, y: newY };
                    redrawOverlay();
                }
                return;
            }
            
            // Moving entire polygon
            if (dragHandle === 'movePolygon' && drawStart) {
                const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
                if (set && set.goodZones[selectedZoneIndex]) {
                    let dx = pct.x - pixelToPercent(drawStart.x, 0).x;
                    let dy = pct.y - pixelToPercent(0, drawStart.y).y;
                    
                    // Shift key constrains to horizontal or vertical
                    if (e.shiftKey) {
                        if (Math.abs(dx) > Math.abs(dy)) {
                            dy = 0; // Horizontal lock
                        } else {
                            dx = 0; // Vertical lock
                        }
                    }
                    
                    set.goodZones[selectedZoneIndex].points = drawStart.points.map(p => ({
                        x: Math.max(0, Math.min(100, p.x + dx)),
                        y: Math.max(0, Math.min(100, p.y + dy))
                    }));
                    redrawOverlay();
                }
                return;
            }
            
            // Moving/resizing rectangle (perfect zones)
            if (dragHandle && drawStart && dragHandle !== 'vertex' && dragHandle !== 'movePolygon') {
                const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
                if (!set) return;
                
                const zone = set.perfectZone;
                if (!zone) return;
                
                const original = drawStart.zone;
                const canvasW = overlayCanvas.width;
                const canvasH = overlayCanvas.height;
                const mouseXPct = (x / canvasW) * 100;
                const mouseYPct = (y / canvasH) * 100;
                
                if (dragHandle === 'move') {
                    let dx = mouseXPct - (drawStart.x / canvasW) * 100;
                    let dy = mouseYPct - (drawStart.y / canvasH) * 100;
                    
                    // Shift key constrains to horizontal or vertical
                    if (e.shiftKey) {
                        if (Math.abs(dx) > Math.abs(dy)) {
                            dy = 0; // Horizontal lock
                        } else {
                            dx = 0; // Vertical lock
                        }
                    }
                    
                    zone.x = Math.max(0, Math.min(100 - original.width, original.x + dx));
                    zone.y = Math.max(0, Math.min(100 - original.height, original.y + dy));
                } else {
                    // Resizing
                    let newX = zone.x, newY = zone.y, newW = zone.width, newH = zone.height;
                    const minSize = PERFECT_MIN_WIDTH;
                    const minHeight = PERFECT_MIN_HEIGHT;
                    
                    if (dragHandle.includes('e')) newW = Math.max(minSize, mouseXPct - original.x);
                    if (dragHandle.includes('w')) {
                        const rightEdge = original.x + original.width;
                        newX = Math.min(mouseXPct, rightEdge - minSize);
                        newW = rightEdge - newX;
                    }
                    if (dragHandle.includes('s')) newH = Math.max(minHeight, mouseYPct - original.y);
                    if (dragHandle.includes('n')) {
                        const bottomEdge = original.y + original.height;
                        newY = Math.min(mouseYPct, bottomEdge - minHeight);
                        newH = bottomEdge - newY;
                    }
                    
                    zone.x = Math.max(0, newX);
                    zone.y = Math.max(0, newY);
                    zone.width = Math.min(newW, 100 - zone.x);
                    zone.height = Math.min(newH, 100 - zone.y);
                }
                
                redrawOverlay();
                updateSetZonesList();
                return;
            }
            
            // Drawing rectangle (perfect zone)
            if (isDrawing && editorMode === 'drawPerfect') {
                const w = x - drawStart.x;
                const h = y - drawStart.y;
                
                tempZone = pixelToPercentRect(
                    w > 0 ? drawStart.x : x,
                    h > 0 ? drawStart.y : y,
                    Math.abs(w),
                    Math.abs(h)
                );
                
                redrawOverlay();
                return;
            }
            
            // Update cursor in select mode
            if (editorMode === 'select') {
                let cursor = 'default';
                
                // Check polygon vertices
                if (selectedSetId && selectedZoneType === 'good' && selectedZoneIndex !== null) {
                    const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
                    if (set && set.goodZones[selectedZoneIndex]?.points) {
                        const pixelPoints = polygonToPixels(set.goodZones[selectedZoneIndex]);
                        for (const p of pixelPoints) {
                            if (Math.hypot(x - p.x, y - p.y) < 10) {
                                cursor = 'pointer';
                                break;
                            }
                        }
                        // Inside polygon = move
                        if (cursor === 'default' && pointInPolygon(pct.x, pct.y, set.goodZones[selectedZoneIndex])) {
                            cursor = 'move';
                        }
                    }
                }
                
                // Check rectangle handles
                if (selectedSetId && selectedZoneType === 'perfect') {
                    const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
                    if (set?.perfectZone) {
                        const zoneRect = percentToPixel(set.perfectZone);
                        const handles = getHandlePositions(zoneRect);
                        
                        for (const h of handles) {
                            if (Math.abs(x - h.x) < 8 && Math.abs(y - h.y) < 8) {
                                const cursors = {
                                    'nw': 'nw-resize', 'ne': 'ne-resize', 'sw': 'sw-resize', 'se': 'se-resize',
                                    'n': 'n-resize', 's': 's-resize', 'e': 'e-resize', 'w': 'w-resize'
                                };
                                cursor = cursors[h.id];
                                break;
                            }
                        }
                        
                        if (cursor === 'default' && 
                            x >= zoneRect.x && x <= zoneRect.x + zoneRect.w &&
                            y >= zoneRect.y && y <= zoneRect.y + zoneRect.h) {
                            cursor = 'move';
                        }
                    }
                }
                
                interactionCanvas.style.cursor = cursor;
            }
        }
        
        function pixelToPercentRect(x, y, w, h) {
            return {
                x: Math.round((x / overlayCanvas.width) * 10000) / 100,
                y: Math.round((y / overlayCanvas.height) * 10000) / 100,
                width: Math.round((w / overlayCanvas.width) * 10000) / 100,
                height: Math.round((h / overlayCanvas.height) * 10000) / 100
            };
        }
        
        function handleMouseUp(e) {
            if (dragHandle) {
                dragHandle = null;
                drawStart = null;
                selectedVertexIndex = null;
                return;
            }
            
            // For polygon drawing, we don't finish on mouseUp - only on clicking near start
            if (editorMode === 'drawGood') return;
            
            if (!isDrawing || !tempZone) {
                isDrawing = false;
                return;
            }
            
            // Rectangle for perfect zone
            if (tempZone.width < PERFECT_MIN_WIDTH || tempZone.height < PERFECT_MIN_HEIGHT) {
                showToast(`Perfect zone must be at least ${PERFECT_MIN_WIDTH}% √ó ${PERFECT_MIN_HEIGHT}% to fit text`, 'error');
                tempZone = null;
                isDrawing = false;
                redrawOverlay();
                return;
            }
            
            const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
            if (set) {
                set.perfectZone = { ...tempZone };
                selectedZoneType = 'perfect';
                selectedZoneIndex = null;
                updateSetZonesList();
            }
            
            tempZone = null;
            isDrawing = false;
            editorMode = 'select';
            updateModeIndicator();
            redrawOverlay();
        }
        
        function handleKeyDown(e) {
            // Don't handle keyboard shortcuts when typing in input fields
            const activeEl = document.activeElement;
            const isTyping = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA');
            
            if (isTyping) return;
            
            // Ctrl+Z / Cmd+Z for undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
                return;
            }
            
            // Ctrl+Y / Cmd+Shift+Z for redo
            if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
                return;
            }
            
            if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                
                // Can't delete when zones are hidden
                if (!zonesVisible) {
                    showToast('Turn on zone visibility to delete', 'info');
                    return;
                }
                
                // Delete selected vertex
                if (selectedVertexIndex !== null && selectedSetId && selectedZoneType === 'good') {
                    const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
                    if (set && set.goodZones[selectedZoneIndex]?.points) {
                        const zone = set.goodZones[selectedZoneIndex];
                        if (zone.points.length > 3) {
                            saveUndoState('delete vertex');
                            zone.points.splice(selectedVertexIndex, 1);
                            selectedVertexIndex = null;
                            updateSetZonesList();
                            redrawOverlay();
                        } else {
                            showToast('Polygon must have at least 3 points', 'error');
                        }
                        return;
                    }
                }
                
                // Delete selected zone
                if (selectedSetId && selectedZoneType) {
                    const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
                    if (set) {
                        saveUndoState('delete zone');
                        if (selectedZoneType === 'perfect') {
                            set.perfectZone = null;
                        } else if (selectedZoneType === 'good' && selectedZoneIndex !== null) {
                            set.goodZones.splice(selectedZoneIndex, 1);
                        }
                        selectedZoneType = null;
                        selectedZoneIndex = null;
                        selectedVertexIndex = null;
                        updateSetZonesList();
                        redrawOverlay();
                    }
                }
            } else if (e.key === 'Escape') {
                // Cancel polygon drawing
                if (polygonPoints.length > 0) {
                    polygonPoints = [];
                }
                editorMode = 'select';
                tempZone = null;
                selectedVertexIndex = null;
                updateModeIndicator();
                redrawOverlay();
            } else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // Arrow keys to nudge selected zone/vertex
                if (!selectedSetId || !selectedZoneType) return;
                if (!zonesVisible) return; // Don't nudge when zones hidden
                
                e.preventDefault();
                
                // Nudge amount: 1% normally, 0.1% with shift for fine control
                const nudge = e.shiftKey ? 0.1 : 1;
                let dx = 0, dy = 0;
                
                if (e.key === 'ArrowUp') dy = -nudge;
                if (e.key === 'ArrowDown') dy = nudge;
                if (e.key === 'ArrowLeft') dx = -nudge;
                if (e.key === 'ArrowRight') dx = nudge;
                
                const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
                if (!set) return;
                
                // Nudge selected vertex
                if (selectedVertexIndex !== null && selectedZoneType === 'good') {
                    const zone = set.goodZones[selectedZoneIndex];
                    if (zone && zone.points) {
                        saveUndoState('nudge vertex');
                        const p = zone.points[selectedVertexIndex];
                        p.x = Math.max(0, Math.min(100, p.x + dx));
                        p.y = Math.max(0, Math.min(100, p.y + dy));
                        updateSetZonesList();
                        redrawOverlay();
                        return;
                    }
                }
                
                // Nudge perfect zone
                if (selectedZoneType === 'perfect' && set.perfectZone) {
                    saveUndoState('nudge perfect zone');
                    set.perfectZone.x = Math.max(0, Math.min(100 - set.perfectZone.width, set.perfectZone.x + dx));
                    set.perfectZone.y = Math.max(0, Math.min(100 - set.perfectZone.height, set.perfectZone.y + dy));
                    updateSetZonesList();
                    redrawOverlay();
                    return;
                }
                
                // Nudge good zone (polygon)
                if (selectedZoneType === 'good' && selectedZoneIndex !== null) {
                    const zone = set.goodZones[selectedZoneIndex];
                    if (zone && zone.points) {
                        saveUndoState('nudge polygon');
                        zone.points = zone.points.map(p => ({
                            x: Math.max(0, Math.min(100, p.x + dx)),
                            y: Math.max(0, Math.min(100, p.y + dy))
                        }));
                        updateSetZonesList();
                        redrawOverlay();
                        return;
                    }
                }
            }
        }
        
        function findZoneAt(x, y) {
            const pct = pixelToPercent(x, y);
            
            // Only find zones in the selected set
            if (!selectedSetId) return null;
            
            const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
            if (!set) return null;
            
            // Check perfect zone first (always rectangle)
            if (set.perfectZone) {
                const rect = percentToPixel(set.perfectZone);
                if (x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h) {
                    return { setId: set.id, type: 'perfect', index: null };
                }
            }
            
            // Check good zones (polygons or legacy rectangles)
            for (let j = set.goodZones.length - 1; j >= 0; j--) {
                const zone = set.goodZones[j];
                
                if (zone.points) {
                    // Polygon
                    if (pointInPolygon(pct.x, pct.y, zone)) {
                        return { setId: set.id, type: 'good', index: j };
                    }
                } else {
                    // Legacy rectangle
                    const rect = percentToPixel(zone);
                    if (x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h) {
                        return { setId: set.id, type: 'good', index: j };
                    }
                }
            }
            
            return null;
        }

        // ============================================
        // VIEW TOGGLE
        // ============================================
        function switchToView(view) {
            editorView = view;
            
            const cropBtn = document.getElementById('cropViewBtn');
            const zoneBtn = document.getElementById('zoneViewBtn');
            const cropContainer = document.getElementById('cropContainer');
            const zoneContainer = document.getElementById('zoneContainer');
            const cropTools = document.getElementById('cropTools');
            const zoneTools = document.getElementById('zoneTools');
            
            if (view === 'crop') {
                cropBtn.classList.add('btn-cyan');
                cropBtn.classList.remove('btn-outline');
                zoneBtn.classList.remove('btn-cyan');
                zoneBtn.classList.add('btn-outline');
                cropContainer.classList.remove('hidden');
                zoneContainer.classList.add('hidden');
                cropTools.classList.remove('hidden');
                zoneTools.classList.add('hidden');
                drawCropView();
            } else {
                zoneBtn.classList.add('btn-cyan');
                zoneBtn.classList.remove('btn-outline');
                cropBtn.classList.remove('btn-cyan');
                cropBtn.classList.add('btn-outline');
                cropContainer.classList.add('hidden');
                zoneContainer.classList.remove('hidden');
                cropTools.classList.add('hidden');
                zoneTools.classList.remove('hidden');
                updateZoneView();
            }
        }
        
        document.getElementById('cropViewBtn').addEventListener('click', () => {
            if (!loadedImage) {
                showToast('Upload an image first', 'error');
                return;
            }
            // Warn if there are existing zones
            const hasZones = currentLevel.zoneSets.some(s => s.goodZones.length > 0 || s.perfectZone);
            if (hasZones && editorView !== 'crop') {
                if (!confirm('Warning: Changing the crop will misalign existing zones. Continue?')) {
                    return;
                }
            }
            switchToView('crop');
        });
        
        document.getElementById('zoneViewBtn').addEventListener('click', () => {
            if (!loadedImage) {
                showToast('Upload an image first', 'error');
                return;
            }
            switchToView('zones');
        });
        
        document.getElementById('resetCropBtn').addEventListener('click', () => {
            if (!loadedImage) return;
            currentLevel.crop = getAutoCrop(loadedImage.width, loadedImage.height);
            drawCropView();
            updateZoneView();
        });
        
        // ============================================
        // MODE BUTTONS
        // ============================================
        function ensureZonesVisible() {
            if (!zonesVisible) {
                zonesVisible = true;
                const btn = document.getElementById('toggleZonesBtn');
                btn.classList.remove('btn-active');
                btn.innerHTML = 'üëÅ Zones';
                redrawOverlay();
            }
        }
        
        document.getElementById('toggleZonesBtn').addEventListener('click', () => {
            zonesVisible = !zonesVisible;
            const btn = document.getElementById('toggleZonesBtn');
            if (zonesVisible) {
                btn.classList.remove('btn-active');
                btn.innerHTML = 'üëÅ Zones';
            } else {
                btn.classList.add('btn-active');
                btn.innerHTML = 'üëÅ‚Äçüó® Zones Hidden';
            }
            redrawOverlay();
        });
        
        document.getElementById('selectModeBtn').addEventListener('click', () => {
            editorMode = 'select';
            updateModeIndicator();
        });
        
        document.getElementById('drawGoodBtn').addEventListener('click', () => {
            if (!selectedSetId) {
                showToast('Select or create a Zone Set first', 'error');
                return;
            }
            ensureZonesVisible(); // Can't draw what you can't see
            editorMode = 'drawGood';
            updateModeIndicator();
        });
        
        document.getElementById('drawPerfectBtn').addEventListener('click', () => {
            if (!selectedSetId) {
                showToast('Select or create a Zone Set first', 'error');
                return;
            }
            ensureZonesVisible(); // Can't draw what you can't see
            editorMode = 'drawPerfect';
            polygonPoints = []; // Clear any in-progress polygon
            updateModeIndicator();
        });
        
        document.getElementById('autoPerfectBtn').addEventListener('click', () => {
            if (DEBUG) console.log('Auto Perfect clicked, selectedSetId:', selectedSetId);
            
            if (!selectedSetId) {
                showToast('Select or create a Zone Set first', 'error');
                return;
            }
            
            const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
            
            if (!set || set.goodZones.length === 0) {
                showToast('Draw a Good Zone first, then use Auto Perfect', 'error');
                return;
            }
            
            // Use selected good zone, or the first good zone if none selected
            let goodZone;
            if (selectedZoneType === 'good' && selectedZoneIndex !== null) {
                goodZone = set.goodZones[selectedZoneIndex];
            } else {
                goodZone = set.goodZones[0];
            }
            
            if (!goodZone) return;
            
            // Ensure it's a polygon
            const polygon = ensurePolygon(goodZone);
            
            // Find the best center point
            const center = findBestPerfectZonePosition(polygon);
            
            // Detailed debug output for troubleshooting
            if (DEBUG) {
                console.log('=== AUTO PERFECT DEBUG ===');
                console.log('Constants: TEXT_WIDTH=' + PERFECT_MIN_WIDTH + '%, TEXT_HEIGHT=' + PERFECT_MIN_HEIGHT + '%');
                console.log('Polygon points:', JSON.stringify(polygon.points, null, 2));
                console.log('Centroid would be at:', getPolygonCentroid(polygon));
                console.log('Best center found:', center);
                const halfW = PERFECT_MIN_WIDTH / 2;
                const halfH = PERFECT_MIN_HEIGHT / 2;
                console.log('Rectangle corners: TL(' + (center.x - halfW).toFixed(2) + ',' + (center.y - halfH).toFixed(2) + ') BR(' + (center.x + halfW).toFixed(2) + ',' + (center.y + halfH).toFixed(2) + ')');
                console.log('=========================');
            }
            
            // Check if the rectangle fits
            if (!center.fits) {
                showToast('Good zone is too small or narrow for the text. Try making it larger or draw the perfect zone manually.', 'error');
                return;
            }
            
            // Create perfect zone at minimum size, centered on that point
            const perfectZone = {
                x: center.x - PERFECT_MIN_WIDTH / 2,
                y: center.y - PERFECT_MIN_HEIGHT / 2,
                width: PERFECT_MIN_WIDTH,
                height: PERFECT_MIN_HEIGHT
            };
            
            // Clamp to bounds
            perfectZone.x = Math.max(0, Math.min(100 - PERFECT_MIN_WIDTH, perfectZone.x));
            perfectZone.y = Math.max(0, Math.min(100 - PERFECT_MIN_HEIGHT, perfectZone.y));
            
            if (DEBUG) console.log('Final perfect zone:', perfectZone);
            
            set.perfectZone = perfectZone;
            selectedZoneType = 'perfect';
            selectedZoneIndex = null;
            
            updateSetZonesList();
            redrawOverlay();
            showToast('Perfect zone placed!', 'success');
        });

        // ============================================
        // ZONE SETS UI
        // ============================================
        function updateZoneSetsList() {
            const container = document.getElementById('zoneSetsList');
            
            if (currentLevel.zoneSets.length === 0) {
                container.innerHTML = '<p class="text-gray-500 text-sm text-center py-4">No zone sets yet</p>';
                return;
            }
            
            container.innerHTML = currentLevel.zoneSets.map(set => `
                <div class="zone-set-item ${set.color}-set ${set.id === selectedSetId ? 'selected' : ''} ${hiddenSets.has(set.id) ? 'opacity-50' : ''}" data-set-id="${set.id}">
                    <div class="flex items-center justify-between">
                        <div>
                            <strong class="text-sm">${set.name || 'Unnamed Set'}</strong>
                            <span class="text-xs text-gray-400 ml-2">(${set.color})</span>
                        </div>
                        <div class="flex gap-1">
                            <button class="visibility-set-btn text-xs px-2 py-1 ${hiddenSets.has(set.id) ? 'bg-yellow-800 hover:bg-yellow-700' : 'bg-gray-700 hover:bg-gray-600'} rounded" title="${hiddenSets.has(set.id) ? 'Show this set' : 'Hide this set'}">${hiddenSets.has(set.id) ? 'üëÅ‚Äçüó®' : 'üëÅ'}</button>
                            <button class="duplicate-set-btn text-xs px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded" title="Duplicate this set">‚ßâ</button>
                            <button class="delete-set-btn text-xs px-2 py-1 bg-red-900 hover:bg-red-800 rounded" title="Delete this set">√ó</button>
                        </div>
                    </div>
                    <div class="text-xs text-gray-500 mt-1">
                        ${set.goodZones.length} good zone${set.goodZones.length !== 1 ? 's' : ''}, 
                        ${set.perfectZone ? '1 perfect zone' : 'no perfect zone'}
                    </div>
                </div>
            `).join('');
            
            // Add click handlers
            container.querySelectorAll('.zone-set-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    // Don't select if clicking a button
                    if (e.target.closest('button')) return;
                    
                    selectedSetId = item.dataset.setId;
                    selectedZoneType = null;
                    selectedZoneIndex = null;
                    selectedVertexIndex = null;
                    updateZoneSetsList();
                    updateZoneSetEditor();
                    redrawOverlay();
                });
                
                // Duplicate button
                item.querySelector('.duplicate-set-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const setId = item.dataset.setId;
                    const originalSet = currentLevel.zoneSets.find(s => s.id === setId);
                    if (originalSet) {
                        const newSet = JSON.parse(JSON.stringify(originalSet)); // Deep clone
                        newSet.id = 'set_' + Date.now();
                        newSet.name = (originalSet.name || 'Unnamed') + ' (copy)';
                        currentLevel.zoneSets.push(newSet);
                        selectedSetId = newSet.id;
                        selectedZoneType = null;
                        selectedZoneIndex = null;
                        updateZoneSetsList();
                        updateZoneSetEditor();
                        redrawOverlay();
                        showToast('Set duplicated!', 'success');
                    }
                });
                
                // Visibility toggle button
                item.querySelector('.visibility-set-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const setId = item.dataset.setId;
                    if (hiddenSets.has(setId)) {
                        hiddenSets.delete(setId);
                    } else {
                        hiddenSets.add(setId);
                    }
                    updateZoneSetsList();
                    redrawOverlay();
                });
                
                // Delete button
                item.querySelector('.delete-set-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const setId = item.dataset.setId;
                    if (confirm('Delete this zone set?')) {
                        currentLevel.zoneSets = currentLevel.zoneSets.filter(s => s.id !== setId);
                        if (selectedSetId === setId) {
                            selectedSetId = currentLevel.zoneSets.length > 0 ? currentLevel.zoneSets[0].id : null;
                            selectedZoneType = null;
                            selectedZoneIndex = null;
                        }
                        updateZoneSetsList();
                        updateZoneSetEditor();
                        redrawOverlay();
                        showToast('Set deleted', 'info');
                    }
                });
            });
        }
        
        function updateZoneSetEditor() {
            const editor = document.getElementById('zoneSetEditor');
            const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
            
            if (!set) {
                editor.classList.add('hidden');
                return;
            }
            
            editor.classList.remove('hidden');
            
            document.getElementById('zoneSetName').value = set.name || '';
            document.getElementById('zoneSetFeedback').value = set.placementFeedback || '';
            document.getElementById('perfectZoneHint').value = set.perfectHint || '';
            
            // Update color buttons
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.classList.toggle('btn-active', btn.dataset.color === set.color);
            });
            
            updateSetZonesList();
        }
        
        function updateSetZonesList() {
            const container = document.getElementById('setZonesList');
            const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
            
            if (!set) {
                container.innerHTML = '<p class="text-gray-500">No zones yet</p>';
                return;
            }
            
            let html = '';
            
            set.goodZones.forEach((zone, idx) => {
                let sizeText;
                if (zone.points) {
                    // Polygon - show point count
                    sizeText = `${zone.points.length} points`;
                } else {
                    // Rectangle
                    sizeText = `${zone.width.toFixed(1)}% √ó ${zone.height.toFixed(1)}%`;
                }
                html += `<div class="flex items-center justify-between py-1 ${selectedZoneType === 'good' && selectedZoneIndex === idx ? 'text-cyan-400' : ''}">
                    <span>Good Zone ${idx + 1}</span>
                    <span class="text-gray-500">${sizeText}</span>
                </div>`;
            });
            
            if (set.perfectZone) {
                html += `<div class="flex items-center justify-between py-1 ${selectedZoneType === 'perfect' ? 'text-cyan-400' : ''}">
                    <span>Perfect Zone</span>
                    <span class="text-gray-500">${set.perfectZone.width.toFixed(1)}% √ó ${set.perfectZone.height.toFixed(1)}%</span>
                </div>`;
            }
            
            container.innerHTML = html || '<p class="text-gray-500">No zones yet</p>';
        }
        
        // Zone set editor event handlers
        document.getElementById('zoneSetName').addEventListener('input', (e) => {
            const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
            if (set) {
                set.name = e.target.value;
                updateZoneSetsList();
            }
        });
        
        document.getElementById('zoneSetFeedback').addEventListener('input', (e) => {
            const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
            if (set) set.placementFeedback = e.target.value;
        });
        
        document.getElementById('perfectZoneHint').addEventListener('input', (e) => {
            const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
            if (set) set.perfectHint = e.target.value;
        });
        
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const set = currentLevel.zoneSets.find(s => s.id === selectedSetId);
                if (set) {
                    set.color = btn.dataset.color;
                    updateZoneSetEditor();
                    updateZoneSetsList();
                    redrawOverlay();
                }
            });
        });
        
        document.getElementById('addZoneSetBtn').addEventListener('click', () => {
            const newSet = {
                id: 'set_' + Date.now(),
                name: 'Zone Set ' + (currentLevel.zoneSets.length + 1),
                color: 'white',
                placementFeedback: '',
                perfectHint: '',
                goodZones: [],
                perfectZone: null
            };
            currentLevel.zoneSets.push(newSet);
            selectedSetId = newSet.id;
            updateZoneSetsList();
            updateZoneSetEditor();
            redrawOverlay();
        });
        
        document.getElementById('deleteZoneSetBtn').addEventListener('click', () => {
            if (!selectedSetId) return;
            if (!confirm('Delete this zone set?')) return;
            
            currentLevel.zoneSets = currentLevel.zoneSets.filter(s => s.id !== selectedSetId);
            selectedSetId = null;
            selectedZoneType = null;
            document.getElementById('zoneSetEditor').classList.add('hidden');
            updateZoneSetsList();
            redrawOverlay();
        });

        // ============================================
        // IMAGE UPLOAD & URL
        // ============================================
        document.getElementById('loadUrlBtn').addEventListener('click', loadImageFromUrl);
        document.getElementById('imageUrlInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') loadImageFromUrl();
        });
        
        async function loadImageFromUrl() {
            const url = document.getElementById('imageUrlInput').value.trim();
            if (!url) return showToast('Enter a URL', 'error');
            
            showLoading('Loading...');
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Fetch failed');
                const blob = await response.blob();
                
                if (response.headers.get('content-type')?.includes('video') || url.endsWith('.webm')) {
                    await extractFrameFromVideo(blob, url);
                } else {
                    await uploadImageBlob(blob, url);
                }
            } catch (error) {
                hideLoading();
                // Try direct load
                currentLevel.imageUrl = url;
                loadImageToCanvas(url);
                showToast('Loaded (not uploaded)', 'info');
            }
        }
        
        async function extractFrameFromVideo(blob, name) {
            return new Promise((resolve) => {
                const video = document.createElement('video');
                video.muted = true;
                video.onloadeddata = () => video.currentTime = 0;
                video.onseeked = async () => {
                    const c = document.createElement('canvas');
                    c.width = video.videoWidth;
                    c.height = video.videoHeight;
                    c.getContext('2d').drawImage(video, 0, 0);
                    c.toBlob(async (b) => {
                        await uploadImageBlob(b, name.replace('.webm', '.jpg'));
                        resolve();
                    }, 'image/jpeg', 0.9);
                };
                video.src = URL.createObjectURL(blob);
            });
        }
        
        async function uploadImageBlob(blob, name) {
            if (!firebaseReady) return showToast('Sign in first', 'error');
            
            const fileName = `${Date.now()}_${name.split('/').pop().replace(/[^a-z0-9.]/gi, '_')}`;
            const storageRef = ref(storage, `game-images/${fileName}`);
            await uploadBytes(storageRef, blob);
            const url = await getDownloadURL(storageRef);
            
            currentLevel.imageUrl = url;
            currentLevel.imagePath = `game-images/${fileName}`;
            loadImageToCanvas(url);
            hideLoading();
            showToast('Uploaded!', 'success');
        }
        
        document.getElementById('imageUpload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            showLoading('Processing...');
            try {
                if (file.type.includes('video') || file.name.endsWith('.webm')) {
                    await extractFrameFromVideo(file, file.name);
                } else {
                    await uploadImageBlob(file, file.name);
                }
            } catch (err) {
                hideLoading();
                showToast('Upload failed', 'error');
            }
        });

        // ============================================
        // LEVEL SAVE/LOAD
        // ============================================
        document.getElementById('saveLevelBtn').addEventListener('click', saveLevel);
        document.getElementById('newLevelBtn').addEventListener('click', newLevel);
        
        async function saveLevel() {
            if (!currentLevel.imageUrl) return showToast('Upload an image first', 'error');
            if (!firebaseReady) return showToast('Sign in first', 'error');
            
            currentLevel.name = document.getElementById('levelName').value || 'Untitled';
            currentLevel.feedback = document.getElementById('levelFeedback').value;
            
            // Validate zone sets
            const warnings = [];
            currentLevel.zoneSets.forEach((set, idx) => {
                const setName = set.name || `Set ${idx + 1}`;
                if (set.goodZones.length === 0) {
                    warnings.push(`"${setName}" has no good zones`);
                }
                if (set.perfectZone && set.goodZones.length > 0) {
                    // Check if perfect zone center is inside any good zone
                    const perfectCenter = {
                        x: set.perfectZone.x + set.perfectZone.width / 2,
                        y: set.perfectZone.y + set.perfectZone.height / 2
                    };
                    const isInside = set.goodZones.some(gz => {
                        const polygon = ensurePolygon(gz);
                        return pointInPolygon(perfectCenter.x, perfectCenter.y, polygon);
                    });
                    if (!isInside) {
                        warnings.push(`"${setName}" perfect zone is outside its good zones`);
                    }
                }
            });
            
            if (warnings.length > 0) {
                const proceed = confirm('Validation warnings:\n\n‚Ä¢ ' + warnings.join('\n‚Ä¢ ') + '\n\nSave anyway?');
                if (!proceed) return;
            }
            
            showLoading('Saving...');
            
            try {
                // Convert zone sets to game format
                const goodZones = { white: [], black: [] };
                const perfectZones = { white: [], black: [] };
                let placementFeedback = '';
                
                currentLevel.zoneSets.forEach(set => {
                    set.goodZones.forEach(zone => {
                        goodZones[set.color].push({ ...zone });
                    });
                    
                    if (set.perfectZone) {
                        perfectZones[set.color].push({
                            ...set.perfectZone,
                            id: set.id,
                            hint: set.perfectHint || ''
                        });
                        if (set.placementFeedback) {
                            placementFeedback = set.placementFeedback;
                        }
                    }
                });
                
                const levelData = {
                    name: currentLevel.name,
                    imageUrl: currentLevel.imageUrl,
                    imagePath: currentLevel.imagePath,
                    crop: currentLevel.crop,
                    feedback: currentLevel.feedback,
                    placementFeedback,
                    goodZones,
                    perfectZones,
                    zoneSets: currentLevel.zoneSets, // Also save raw zone sets
                    updatedAt: serverTimestamp()
                };
                
                if (currentLevel.id) {
                    await updateDoc(doc(db, 'levels', currentLevel.id), levelData);
                } else {
                    levelData.createdAt = serverTimestamp();
                    const docRef = await addDoc(collection(db, 'levels'), levelData);
                    currentLevel.id = docRef.id;
                }
                
                hideLoading();
                showToast('Saved!', 'success');
                isDirty = false;
            } catch (err) {
                hideLoading();
                showToast('Save failed: ' + err.message, 'error');
            }
        }
        
        function newLevel() {
            // Check for unsaved changes
            if (isDirty) {
                if (!confirm('You have unsaved changes. Discard them and create a new level?')) {
                    return;
                }
            }
            
            currentLevel = {
                id: null, name: '', imageUrl: '', imagePath: '',
                crop: null, feedback: '', zoneSets: []
            };
            document.getElementById('levelName').value = '';
            document.getElementById('levelFeedback').value = '';
            document.getElementById('zoneSetEditor').classList.add('hidden');
            selectedSetId = null;
            loadedImage = null;
            hiddenSets.clear(); // Clear any hidden set state
            undoHistory = [];
            redoHistory = [];
            isDirty = false;
            
            // Clear both views
            cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            document.getElementById('cropPlaceholder').classList.remove('hidden');
            
            const zoneContainer = document.getElementById('zoneContainer');
            zoneContainer.style.backgroundImage = '';
            if (overlayCtx) overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            document.getElementById('zonePlaceholder').classList.remove('hidden');
            
            // Switch to crop view
            switchToView('crop');
            updateZoneSetsList();
        }
        
        async function loadLevel(levelId) {
            // Check for unsaved changes
            if (isDirty) {
                if (!confirm('You have unsaved changes. Discard them and load this level?')) {
                    return;
                }
            }
            
            showLoading('Loading...');
            hiddenSets.clear(); // Clear any hidden set state
            undoHistory = [];
            redoHistory = [];
            try {
                const docSnap = await getDoc(doc(db, 'levels', levelId));
                if (!docSnap.exists()) throw new Error('Not found');
                
                const data = docSnap.data();
                
                // Try to load zone sets if available, otherwise convert from old format
                if (data.zoneSets && data.zoneSets.length > 0) {
                    currentLevel = {
                        id: docSnap.id,
                        name: data.name || '',
                        imageUrl: data.imageUrl,
                        imagePath: data.imagePath || '',
                        crop: data.crop || null, // Will be auto-calculated on image load if null
                        feedback: data.feedback || '',
                        zoneSets: data.zoneSets
                    };
                } else {
                    // Convert from old format
                    currentLevel = {
                        id: docSnap.id,
                        name: data.name || '',
                        imageUrl: data.imageUrl,
                        imagePath: data.imagePath || '',
                        crop: data.crop || null,
                        feedback: data.feedback || '',
                        zoneSets: convertOldFormat(data)
                    };
                }
                
                document.getElementById('levelName').value = currentLevel.name;
                document.getElementById('levelFeedback').value = currentLevel.feedback;
                
                loadImageToCanvas(currentLevel.imageUrl);
                selectedSetId = currentLevel.zoneSets[0]?.id || null;
                updateZoneSetsList();
                updateZoneSetEditor();
                
                // Switch to Sweet Spot tab > Editor sub-tab
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
                document.querySelector('[data-tab="sweetspot"]').classList.add('active');
                document.getElementById('sweetspotTab').classList.remove('hidden');
                document.getElementById('sweetspotSubTabs').classList.remove('hidden');
                
                // Activate editor sub-tab
                document.querySelectorAll('.sub-tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.sub-tab-content').forEach(c => c.classList.add('hidden'));
                document.querySelector('[data-subtab="editor"]').classList.add('active');
                document.getElementById('editorSubTab').classList.remove('hidden');
                
                // If level has zones, go to zone view; otherwise stay in crop view
                const hasZones = currentLevel.zoneSets.some(s => s.goodZones.length > 0 || s.perfectZone);
                if (hasZones) {
                    // Small delay to ensure image is loaded
                    setTimeout(() => switchToView('zones'), 100);
                }
                
                hideLoading();
                isDirty = false;
            } catch (err) {
                hideLoading();
                showToast('Load failed', 'error');
            }
        }
        
        function convertOldFormat(data) {
            const sets = [];
            
            ['white', 'black'].forEach(color => {
                const goodZones = data.goodZones?.[color] || [];
                const perfectZones = data.perfectZones?.[color] || [];
                
                if (goodZones.length > 0 || perfectZones.length > 0) {
                    // Create one set per perfect zone, or one set if no perfect zones
                    if (perfectZones.length > 0) {
                        perfectZones.forEach((pz, idx) => {
                            sets.push({
                                id: 'set_' + color + '_' + idx,
                                name: `${color.charAt(0).toUpperCase() + color.slice(1)} Set ${idx + 1}`,
                                color,
                                placementFeedback: data.placementFeedback || '',
                                perfectHint: pz.hint || '',
                                goodZones: idx === 0 ? goodZones.map(z => ({...z})) : [],
                                perfectZone: { x: pz.x, y: pz.y, width: pz.width, height: pz.height }
                            });
                        });
                    } else if (goodZones.length > 0) {
                        sets.push({
                            id: 'set_' + color + '_0',
                            name: `${color.charAt(0).toUpperCase() + color.slice(1)} Set`,
                            color,
                            placementFeedback: '',
                            perfectHint: '',
                            goodZones: goodZones.map(z => ({...z})),
                            perfectZone: null
                        });
                    }
                }
            });
            
            return sets;
        }

        // ============================================
        // LEVELS LIST
        // ============================================
        async function loadLevelsList() {
            const container = document.getElementById('levelsList');
            if (!firebaseReady) {
                container.innerHTML = '<p class="text-gray-500 col-span-full text-center py-12">Sign in first</p>';
                return;
            }
            
            try {
                const snapshot = await getDocs(collection(db, 'levels'));
                if (snapshot.empty) {
                    container.innerHTML = '<p class="text-gray-500 col-span-full text-center py-12">No levels yet</p>';
                    return;
                }
                
                container.innerHTML = '';
                snapshot.docs.forEach(docSnap => {
                    const level = docSnap.data();
                    const card = document.createElement('div');
                    card.className = 'level-card';
                    card.style.cursor = 'pointer';
                    card.innerHTML = `
                        <img src="${level.imageUrl}" alt="${level.name}">
                        <div class="p-3">
                            <h4 class="font-bold truncate text-sm">${level.name || 'Untitled'}</h4>
                            <div class="flex gap-2 mt-2">
                                <button class="btn btn-outline btn-sm flex-1 edit-btn">Edit</button>
                                <button class="btn btn-danger btn-sm del-btn">√ó</button>
                            </div>
                        </div>
                    `;
                    // Click on card or image to edit
                    card.addEventListener('click', () => loadLevel(docSnap.id));
                    card.querySelector('img').style.cursor = 'pointer';
                    card.querySelector('.edit-btn').addEventListener('click', (e) => { e.stopPropagation(); loadLevel(docSnap.id); });
                    card.querySelector('.del-btn').addEventListener('click', async (e) => {
                        e.stopPropagation();
                        if (confirm('Delete?')) {
                            await deleteDoc(doc(db, 'levels', docSnap.id));
                            loadLevelsList();
                        }
                    });
                    container.appendChild(card);
                });
            } catch (err) {
                container.innerHTML = '<p class="text-red-400 col-span-full text-center py-12">Error</p>';
            }
        }
        
        document.getElementById('refreshLevelsBtn').addEventListener('click', loadLevelsList);

        // ============================================
        // SCORES LIST
        // ============================================
        
        // Map gameId to display name
        const GAME_NAMES = {
            'sweet-spot': 'Sweet Spot',
            'find-the-center': 'Find the Center',
            'perfect-alignment': 'Perfect Alignment',
            'balanced-placement': 'Balanced Placement',
            'picture-perfect': 'Picture Perfect',
            // Add more games here as they're created
        };
        
        function getGameDisplayName(gameId) {
            return GAME_NAMES[gameId] || gameId || 'Unknown';
        }
        
        async function loadScoresList() {
            const tbody = document.getElementById('scoresTableBody');
            const totalCount = document.getElementById('scoresTotalCount');
            
            if (!firebaseReady) {
                tbody.innerHTML = '<tr><td colspan="8" class="py-8 text-center text-gray-500">Sign in first</td></tr>';
                return;
            }
            
            try {
                const gameFilter = document.getElementById('scoresGameFilter').value;
                const playerSearch = document.getElementById('scoresPlayerSearch').value.toLowerCase().trim();
                const statusFilter = document.getElementById('scoresFilter').value;
                const limitVal = parseInt(document.getElementById('scoresLimit').value);
                
                // Build query - can filter by gameId in Firestore
                let q;
                if (gameFilter !== 'all') {
                    q = query(
                        collection(db, 'scores'),
                        where('gameId', '==', gameFilter),
                        orderBy('score', 'desc'),
                        limit(limitVal)
                    );
                } else {
                    q = query(
                        collection(db, 'scores'),
                        orderBy('score', 'desc'),
                        limit(limitVal)
                    );
                }
                
                const snapshot = await getDocs(q);
                
                if (snapshot.empty) {
                    tbody.innerHTML = '<tr><td colspan="8" class="py-8 text-center text-gray-500">No scores found</td></tr>';
                    totalCount.textContent = '';
                    return;
                }
                
                let scores = snapshot.docs.map(docSnap => ({ id: docSnap.id, ...docSnap.data() }));
                
                // Apply status filter (JS side)
                if (statusFilter === 'flagged') {
                    scores = scores.filter(s => s.flagged);
                } else if (statusFilter === 'unflagged') {
                    scores = scores.filter(s => !s.flagged);
                }
                
                // Apply player search (JS side - searches email and name)
                if (playerSearch) {
                    scores = scores.filter(s => 
                        (s.email && s.email.toLowerCase().includes(playerSearch)) ||
                        (s.displayName && s.displayName.toLowerCase().includes(playerSearch))
                    );
                }
                
                if (scores.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="8" class="py-8 text-center text-gray-500">No matching scores</td></tr>';
                    totalCount.textContent = '';
                    return;
                }
                
                tbody.innerHTML = scores.map((s, i) => {
                    const date = s.timestamp?.toDate ? s.timestamp.toDate().toLocaleString() : 'N/A';
                    const flaggedClass = s.flagged ? 'bg-yellow-900/30' : '';
                    const gameName = getGameDisplayName(s.gameId);
                    return `
                        <tr class="border-b border-gray-800 hover:bg-gray-800/50 ${flaggedClass}" data-id="${s.id}">
                            <td class="py-3 px-2 font-bold text-gray-400">#${i + 1}</td>
                            <td class="py-3 px-2 text-xs text-gray-300">${escapeHtml(gameName)}</td>
                            <td class="py-3 px-2 font-bold">${escapeHtml(s.initials || '???')}</td>
                            <td class="py-3 px-2 font-bold text-cyan-400">${s.score}</td>
                            <td class="py-3 px-2 text-gray-400 text-xs">${escapeHtml(s.email || '')}</td>
                            <td class="py-3 px-2 text-gray-400 text-xs">${escapeHtml(s.displayName || '')}</td>
                            <td class="py-3 px-2 text-gray-500 text-xs">${date}</td>
                            <td class="py-3 px-2">
                                <div class="flex gap-1">
                                    <button class="btn btn-outline btn-sm flag-btn" title="${s.flagged ? 'Unflag' : 'Flag'}">${s.flagged ? 'üö©' : '‚öë'}</button>
                                    <button class="btn btn-danger btn-sm del-score-btn" title="Delete">√ó</button>
                                </div>
                            </td>
                        </tr>
                    `;
                }).join('');
                
                totalCount.textContent = `Showing ${scores.length} scores`;
                
                // Add event listeners to buttons
                tbody.querySelectorAll('.flag-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const row = e.target.closest('tr');
                        const id = row.dataset.id;
                        const isFlagged = btn.textContent === 'üö©';
                        await updateDoc(doc(db, 'scores', id), { flagged: !isFlagged });
                        loadScoresList();
                    });
                });
                
                tbody.querySelectorAll('.del-score-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const row = e.target.closest('tr');
                        const id = row.dataset.id;
                        if (confirm('Delete this score?')) {
                            await deleteDoc(doc(db, 'scores', id));
                            loadScoresList();
                        }
                    });
                });
                
            } catch (err) {
                console.error('Load scores error:', err);
                tbody.innerHTML = '<tr><td colspan="8" class="py-8 text-center text-red-400">Error loading scores</td></tr>';
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        async function exportScoresCSV() {
            if (!firebaseReady) {
                showToast('Sign in first', 'error');
                return;
            }
            
            try {
                showLoading('Exporting...');
                
                const gameFilter = document.getElementById('scoresGameFilter').value;
                const playerSearch = document.getElementById('scoresPlayerSearch').value.toLowerCase().trim();
                const statusFilter = document.getElementById('scoresFilter').value;
                
                // Build query
                let q;
                if (gameFilter !== 'all') {
                    q = query(
                        collection(db, 'scores'),
                        where('gameId', '==', gameFilter),
                        orderBy('score', 'desc'),
                        limit(1000)
                    );
                } else {
                    q = query(
                        collection(db, 'scores'),
                        orderBy('score', 'desc'),
                        limit(1000)
                    );
                }
                
                const snapshot = await getDocs(q);
                
                if (snapshot.empty) {
                    hideLoading();
                    showToast('No scores to export', 'info');
                    return;
                }
                
                let scores = snapshot.docs.map(docSnap => ({ id: docSnap.id, ...docSnap.data() }));
                
                // Apply filters
                if (statusFilter === 'flagged') {
                    scores = scores.filter(s => s.flagged);
                } else if (statusFilter === 'unflagged') {
                    scores = scores.filter(s => !s.flagged);
                }
                
                if (playerSearch) {
                    scores = scores.filter(s => 
                        (s.email && s.email.toLowerCase().includes(playerSearch)) ||
                        (s.displayName && s.displayName.toLowerCase().includes(playerSearch))
                    );
                }
                
                if (scores.length === 0) {
                    hideLoading();
                    showToast('No matching scores to export', 'info');
                    return;
                }
                
                // Create CSV
                const headers = ['Rank', 'Game', 'Initials', 'Score', 'Email', 'Name', 'Date', 'Levels', 'Flagged'];
                const rows = scores.map((s, i) => {
                    const date = s.timestamp?.toDate ? s.timestamp.toDate().toISOString() : '';
                    return [
                        i + 1,
                        `"${(getGameDisplayName(s.gameId)).replace(/"/g, '""')}"`,
                        `"${(s.initials || '').replace(/"/g, '""')}"`,
                        s.score,
                        `"${(s.email || '').replace(/"/g, '""')}"`,
                        `"${(s.displayName || '').replace(/"/g, '""')}"`,
                        date,
                        s.levelCount || '',
                        s.flagged ? 'Yes' : ''
                    ].join(',');
                });
                
                const csv = [headers.join(','), ...rows].join('\n');
                
                // Download with date and filter info in filename
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const filterSuffix = gameFilter !== 'all' ? `-${gameFilter}` : '-all-games';
                a.download = `leaderboard${filterSuffix}-${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                URL.revokeObjectURL(url);
                
                hideLoading();
                showToast(`Exported ${scores.length} scores!`, 'success');
            } catch (err) {
                hideLoading();
                console.error('Export error:', err);
                showToast('Export failed', 'error');
            }
        }
        
        document.getElementById('refreshScoresBtn').addEventListener('click', loadScoresList);
        document.getElementById('exportScoresBtn').addEventListener('click', exportScoresCSV);
        document.getElementById('scoresGameFilter').addEventListener('change', loadScoresList);
        document.getElementById('scoresPlayerSearch').addEventListener('input', debounce(loadScoresList, 300));
        document.getElementById('scoresFilter').addEventListener('change', loadScoresList);
        document.getElementById('scoresLimit').addEventListener('change', loadScoresList);
        
        // Debounce helper for search input
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // ============================================
        // MIGRATION (same as before, condensed)
        // ============================================
        const originalGameImages = [
            { src: 'https://pdr-assets.b-cdn.net/collections/herbert-geddes-life-in-japan/People_in_boats_on_waterways_through_rice_fields;_snow-covered_mountain_in_background._(19329128803).jpg', name: 'Mountain Rice Fields', goodZones: { white: [{ x: 25, y: 75, width: 75, height: 25 }], black: [{ x: 0.9, y: 0, width: 40.5, height: 38.1 }, { x: 41.4, y: 0, width: 57.1, height: 25 }] }, perfectZones: { white: [{ id: 'water_centered', hint: "Shifted right to align with the clearest water.", x: 40, y: 75, width: 30, height: 20 }], black: [{ id: 'sky_peak_centered', hint: "Centered above the mountain peak.", x: 35.75, y: 3, width: 30, height: 20 }, { id: 'sky_left_balanced', hint: "Balanced between edge and peak.", x: 10.3, y: 5.7, width: 30, height: 20 }] } },
            { src: 'https://pdr-assets.b-cdn.net/collections/nathaniel-hawthorne-s-tanglewood-tales-illustrated-by-virginia-frances-sterrett-1921/4_2fabcd2a0_b.jpg', name: 'Tanglewood Dragon', goodZones: { white: [], black: [{ x: 5.6, y: 67, width: 88.885, height: 33 }, { x: 5.6, y: 53, width: 34.4, height: 14 }] }, perfectZones: { white: [], black: [{ id: 'creative', hint: "Excellent creative composition!", x: 10, y: 58, width: 30, height: 20 }, { id: 'centered', hint: "Solid! For more dynamic composition, notice where the dragon looks.", x: 35, y: 73.5, width: 30, height: 20 }] } },
            { src: 'https://pdr-assets.b-cdn.net/collections/correct-postures-for-housework-1920s/3856279792_f5eb5d1399_z.jpg', name: 'Housework Postures', goodZones: { white: [], black: [{ x: 22.47, y: 0, width: 43.2, height: 36.7 }] }, perfectZones: { white: [], black: [{ x: 29.2, y: 8.35, width: 30, height: 20 }] } },
            { src: 'https://pdr-assets.b-cdn.net/collections/through-the-first-antarctic-night-1900/48103624963_32ec491012_b.jpg', name: 'Antarctic Iceberg', goodZones: { white: [{ x: 0, y: 5, width: 100, height: 32.4 }], black: [{ x: 0, y: 5, width: 100, height: 32.4 }] }, perfectZones: { white: [{ x: 38, y: 11.2, width: 30, height: 20 }], black: [{ x: 38, y: 11.2, width: 30, height: 20 }] }, placementFeedback: "Perfect spot is centered above the iceberg." },
            { src: 'https://pdr-assets.b-cdn.net/collections/flowers-and-pictures-of-the-holy-land/10171710394_a7bd417a9f_o.jpg', name: 'Holy Land Flowers', goodZones: { white: [], black: [{ x: 1.7, y: 2.5, width: 96.6, height: 22.5 }] }, perfectZones: { white: [], black: [{ x: 35, y: 3.75, width: 30, height: 20 }] } },
            { src: 'https://pdr-assets.b-cdn.net/collections/photographs-of-models-of-the-moon-1874/45077382895_af6af4615d_b.jpg', name: 'Moon Model', goodZones: { white: [{ x: 52.1, y: 4.5, width: 42.5, height: 29.775 }], black: [] }, perfectZones: { white: [{ x: 54.5, y: 8.5, width: 30, height: 20 }], black: [] }, placementFeedback: "Uses the largest dark, clear area." },
            { src: 'https://pdr-assets.b-cdn.net/collections/herbert-geddes-life-in-japan/Women_preparing_rice_field_in_mud._(19327195784).jpg', name: 'Rice Field Workers', goodZones: { white: [{ x: 38.9, y: 0, width: 59.3, height: 20.2 }], black: [] }, perfectZones: { white: [{ x: 50.5, y: 0.1, width: 30, height: 20 }], black: [] }, placementFeedback: "Uses the largest dark area." },
            { src: 'https://pdr-assets.b-cdn.net/shop/cp-2-small.jpg', name: 'Busy Image (No Spot)', goodZones: { white: [], black: [] }, perfectZones: { white: [], black: [] }, feedback: "No good spot. Too busy for text." },
            { src: 'https://pdr-assets.b-cdn.net/collections/watercolours-from-a-16th-century-de-materia-medica/20879595101_be37994770_o.jpg', name: 'Materia Medica', goodZones: { white: [], black: [{ x: 12.25, y: 50.5, width: 35.8, height: 30.5 }] }, perfectZones: { white: [], black: [{ x: 15.15, y: 55.75, width: 30, height: 20 }] } },
            { src: 'https://pdr-assets.b-cdn.net/collections/los-angeles-alligator-farm/alligator-farm-14.jpg', name: 'Alligator Farm (No Spot)', goodZones: { white: [], black: [] }, perfectZones: { white: [], black: [] }, feedback: "No good spot. Too busy for text." }
        ];
        
        document.getElementById('startMigrationBtn').addEventListener('click', async () => {
            if (!firebaseReady) return showToast('Sign in first', 'error');
            
            const progress = document.getElementById('migrationProgress');
            const count = document.getElementById('migrationCount');
            const bar = document.getElementById('migrationBar');
            const log = document.getElementById('migrationLog');
            
            progress.classList.remove('hidden');
            log.innerHTML = '';
            
            let done = 0;
            const total = originalGameImages.length;
            
            for (const img of originalGameImages) {
                try {
                    log.innerHTML += `<div class="text-gray-400">Downloading: ${img.name}...</div>`;
                    const resp = await fetch(img.src);
                    if (!resp.ok) throw new Error('Fetch failed');
                    const blob = await resp.blob();
                    
                    const fileName = `${Date.now()}_${img.name.replace(/[^a-z0-9]/gi, '_')}.jpg`;
                    const storageRef = ref(storage, `game-images/${fileName}`);
                    await uploadBytes(storageRef, blob);
                    const url = await getDownloadURL(storageRef);
                    
                    await addDoc(collection(db, 'levels'), {
                        name: img.name,
                        imageUrl: url,
                        imagePath: `game-images/${fileName}`,
                        feedback: img.feedback || '',
                        placementFeedback: img.placementFeedback || '',
                        goodZones: img.goodZones,
                        perfectZones: img.perfectZones,
                        createdAt: serverTimestamp(),
                        updatedAt: serverTimestamp()
                    });
                    
                    log.innerHTML += `<div class="text-green-400">‚úì ${img.name}</div>`;
                } catch (err) {
                    log.innerHTML += `<div class="text-red-400">‚úó ${img.name}: ${err.message}</div>`;
                }
                done++;
                count.textContent = `${done} / ${total}`;
                bar.style.width = `${(done/total)*100}%`;
                log.scrollTop = log.scrollHeight;
            }
            
            showToast('Migration complete!', 'success');
        });

        // ============================================
        // PICTURE PERFECT IMAGES MANAGEMENT
        // ============================================
        let ppImages = [];
        
        const PP_DEFAULT_IMAGES = [
            { imageUrl: 'https://images.pexels.com/photos/1036623/pexels-photo-1036623.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1', name: 'Portrait 1' },
            { imageUrl: 'https://images.pexels.com/photos/3763188/pexels-photo-3763188.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1', name: 'Portrait 2' },
            { imageUrl: 'https://images.pexels.com/photos/220453/pexels-photo-220453.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1', name: 'Portrait 3' },
            { imageUrl: 'https://images.pexels.com/photos/1382731/pexels-photo-1382731.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1', name: 'Portrait 4' },
            { imageUrl: 'https://images.pexels.com/photos/774909/pexels-photo-774909.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1', name: 'Portrait 5' },
            { imageUrl: 'https://images.pexels.com/photos/1559486/pexels-photo-1559486.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1', name: 'Portrait 6' },
            { imageUrl: 'https://images.pexels.com/photos/1222271/pexels-photo-1222271.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1', name: 'Portrait 7' },
            { imageUrl: 'https://images.pexels.com/photos/1681010/pexels-photo-1681010.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1', name: 'Portrait 8' },
            { imageUrl: 'https://images.pexels.com/photos/846741/pexels-photo-846741.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1', name: 'Portrait 9' },
            { imageUrl: 'https://images.pexels.com/photos/91227/pexels-photo-91227.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1', name: 'Portrait 10' }
        ];
        
        async function loadPPImagesList() {
            const container = document.getElementById('ppImagesList');
            container.innerHTML = '<p class="text-gray-500 col-span-full text-center py-8">Loading...</p>';
            
            try {
                const snapshot = await getDocs(collection(db, 'picture-perfect-images'));
                ppImages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Update stats
                const enabledCount = ppImages.filter(img => img.enabled !== false).length;
                document.getElementById('ppTotalCount').textContent = `Total: ${ppImages.length}`;
                document.getElementById('ppEnabledCount').textContent = `Enabled: ${enabledCount}`;
                document.getElementById('ppDisabledCount').textContent = `Disabled: ${ppImages.length - enabledCount}`;
                
                if (ppImages.length === 0) {
                    container.innerHTML = '<p class="text-gray-500 col-span-full text-center py-8">No images yet. Click "Seed Default Images" to add the starter images, or add your own above.</p>';
                    return;
                }
                
                renderPPImagesList();
            } catch (error) {
                console.error('Load PP images error:', error);
                container.innerHTML = `<p class="text-red-400 col-span-full text-center py-8">Error loading images: ${error.message}</p>`;
            }
        }
        
        function renderPPImagesList() {
            const container = document.getElementById('ppImagesList');
            
            container.innerHTML = ppImages.map(img => `
                <div class="relative group rounded-lg overflow-hidden bg-gray-800 ${img.enabled === false ? 'opacity-50' : ''}">
                    <img src="${escapeHtml(img.imageUrl)}" alt="${escapeHtml(img.name || 'Image')}" 
                         class="w-full h-32 object-cover" 
                         onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22><rect fill=%22%23333%22 width=%22100%22 height=%22100%22/><text fill=%22%23999%22 x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22>Error</text></svg>'">
                    <div class="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-60 transition-all flex items-center justify-center gap-2 opacity-0 group-hover:opacity-100">
                        <button onclick="togglePPImage('${img.id}')" class="btn btn-sm ${img.enabled === false ? 'btn-green' : 'btn-outline'}" title="${img.enabled === false ? 'Enable' : 'Disable'}">
                            ${img.enabled === false ? '‚úì' : '‚äò'}
                        </button>
                        <button onclick="deletePPImage('${img.id}')" class="btn btn-sm btn-danger" title="Delete">‚úï</button>
                    </div>
                    <div class="p-2 text-xs truncate">${escapeHtml(img.name || 'Unnamed')}</div>
                </div>
            `).join('');
        }
        
        async function addPPImage(url, name) {
            if (!url) {
                showToast('Please enter an image URL', 'error');
                return;
            }
            
            // Validate URL
            try {
                new URL(url);
            } catch {
                showToast('Invalid URL format', 'error');
                return;
            }
            
            try {
                await addDoc(collection(db, 'picture-perfect-images'), {
                    imageUrl: url,
                    name: name || 'Unnamed',
                    enabled: true,
                    createdAt: serverTimestamp()
                });
                
                showToast('Image added!', 'success');
                document.getElementById('ppNewImageUrl').value = '';
                document.getElementById('ppNewImageName').value = '';
                loadPPImagesList();
            } catch (error) {
                console.error('Add PP image error:', error);
                showToast('Failed to add image: ' + error.message, 'error');
            }
        }
        
        window.togglePPImage = async function(imageId) {
            try {
                const img = ppImages.find(i => i.id === imageId);
                if (!img) return;
                
                const newEnabled = img.enabled === false ? true : false;
                await updateDoc(doc(db, 'picture-perfect-images', imageId), {
                    enabled: newEnabled
                });
                
                showToast(newEnabled ? 'Image enabled' : 'Image disabled', 'success');
                loadPPImagesList();
            } catch (error) {
                console.error('Toggle PP image error:', error);
                showToast('Failed to update image: ' + error.message, 'error');
            }
        };
        
        window.deletePPImage = async function(imageId) {
            if (!confirm('Delete this image?')) return;
            
            try {
                await deleteDoc(doc(db, 'picture-perfect-images', imageId));
                showToast('Image deleted', 'success');
                loadPPImagesList();
            } catch (error) {
                console.error('Delete PP image error:', error);
                showToast('Failed to delete image: ' + error.message, 'error');
            }
        };
        
        async function seedPPDefaultImages() {
            if (!confirm('This will add 10 default portrait images. Continue?')) return;
            
            try {
                let added = 0;
                for (const img of PP_DEFAULT_IMAGES) {
                    await addDoc(collection(db, 'picture-perfect-images'), {
                        imageUrl: img.imageUrl,
                        name: img.name,
                        enabled: true,
                        createdAt: serverTimestamp()
                    });
                    added++;
                }
                
                showToast(`Added ${added} default images!`, 'success');
                loadPPImagesList();
            } catch (error) {
                console.error('Seed PP images error:', error);
                showToast('Failed to seed images: ' + error.message, 'error');
            }
        }
        
        // PP Images event listeners
        document.getElementById('ppAddImageBtn').addEventListener('click', () => {
            const url = document.getElementById('ppNewImageUrl').value.trim();
            const name = document.getElementById('ppNewImageName').value.trim();
            addPPImage(url, name);
        });
        
        document.getElementById('ppNewImageUrl').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const url = document.getElementById('ppNewImageUrl').value.trim();
                const name = document.getElementById('ppNewImageName').value.trim();
                addPPImage(url, name);
            }
        });
        
        document.getElementById('ppRefreshBtn').addEventListener('click', loadPPImagesList);
        document.getElementById('ppMigrateBtn').addEventListener('click', seedPPDefaultImages);

        // ============================================
        // INIT
        // ============================================
        if (DEBUG) console.log('Script loaded, initializing...');
        try {
            initCanvases();
            if (DEBUG) console.log('Canvases initialized');
        } catch (e) {
            console.error('initCanvases error:', e);
        }
        updateModeIndicator();
        
        // Show migration tab only in debug mode
        if (DEBUG) {
            document.getElementById('migrateTabBtn').classList.remove('hidden');
        }
        
        // Warn about unsaved changes when leaving page
        window.addEventListener('beforeunload', (e) => {
            if (isDirty) {
                e.preventDefault();
                e.returnValue = ''; // Required for Chrome
                return 'You have unsaved changes. Are you sure you want to leave?';
            }
        });
        
        if (DEBUG) console.log('Admin panel ready');
    </script>
</body>
</html>
